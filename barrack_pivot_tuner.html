<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Barrack Pivot Tuner (v2)</title>
  <style>
    html, body { height:100%; margin:0; background:#0b0b10; color:#e8e8f0; font:14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    .wrap { display:grid; grid-template-columns: 420px 1fr; height:100%; }
    .panel { border-right:1px solid #22223a; padding:14px; overflow:auto; }
    .panel h1 { font-size:16px; margin:0 0 8px; }
    .panel small { color:#a9a9c2; display:block; margin-bottom:10px; }
    .row { display:grid; grid-template-columns: 90px 1fr; gap:10px; align-items:center; margin:8px 0; }
    input, select, button { width:100%; padding:8px 10px; background:#12121c; border:1px solid #2a2a45; color:#e8e8f0; border-radius:8px; }
    button { cursor:pointer; }
    .hint { color:#a9a9c2; margin-top:10px; }
    .kbd { display:inline-block; padding:2px 6px; border:1px solid #2a2a45; border-radius:6px; background:#12121c; margin:0 2px; }
    .err { color:#ff9090; white-space:pre-wrap; }
    .ok { color:#9dffb0; }
    .canvasWrap { position:relative; overflow:hidden; }
    canvas { display:block; width:100%; height:100%; }
    .overlay {
      position:absolute; left:12px; bottom:12px; background:rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.12); border-radius:10px; padding:10px 12px;
      max-width:min(640px, calc(100% - 24px));
      backdrop-filter: blur(6px);
    }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.18); margin-right:6px; }
  </style>
</head>
<body>
<div class="wrap">
  <div class="panel">
    <h1>üß∞ Barrack Pivot Tuner v2</h1>
    <small>ÎßâÏÇ¨(3√ó2) Í∏∞Ï§ÄÏúºÎ°ú Ïò§ÌîÑÏÖã/ÌîºÎ≤ó Ïû°Í≥† Í∞í ÎΩëÎäî Ìà¥. <b>ÌååÏùº://Î°ú Ïó¥Î©¥ fetchÍ∞Ä ÎßâÌûê Ïàò ÏûàÏúºÎãà Î°úÏª¨ ÏÑúÎ≤ÑÎ°ú Ïó¥Ïñ¥.</b></small>

    <div class="row">
      <div>Atlas JS</div>
      <select id="atlasJsPick"></select>
    </div>

    <div class="row">
      <div>Idle JSON</div>
      <input id="idlePath" value="asset/sprite/const/normal/barrack/barrack_idle.json"/>
    </div>
    <div class="row">
      <div>Const JSON</div>
      <input id="constPath" value="asset/sprite/const/const_anim/barrack/barrack_const.json"/>
    </div>
    <div class="row">
      <div>Destr JSON</div>
      <input id="destPath" value="asset/sprite/const/distruct/barrack/barrack_distruct.json"/>
    </div>

    <div class="row">
      <div>Mode</div>
      <select id="mode">
        <option value="idle">idle</option>
        <option value="const">const</option>
        <option value="dest">dest</option>
      </select>
    </div>

    <div class="row">
      <div>Frame</div>
      <select id="frameSel"></select>
    </div>

    <div class="row">
      <div>Scale</div>
      <input id="scale" type="number" step="0.05" value="1.0"/>
    </div>

    <div class="row">
      <div>Offset X</div>
      <input id="offX" type="number" step="1" value="0"/>
    </div>
    <div class="row">
      <div>Offset Y</div>
      <input id="offY" type="number" step="1" value="0"/>
    </div>

    <div class="row">
      <div>Pivot X</div>
      <input id="pivX" type="number" step="0.01" value="0.50"/>
    </div>
    <div class="row">
      <div>Pivot Y</div>
      <input id="pivY" type="number" step="0.01" value="0.52"/>
    </div>

    <div class="row">
      <div></div>
      <button id="copyBtn">Í∞í Î≥µÏÇ¨ (ÏΩòÏÜî/ÌÅ¥Î¶ΩÎ≥¥Îìú)</button>
    </div>

    <div class="hint">
      Ï°∞Ïûë: <span class="kbd">‚Üê‚Üë‚Üí‚Üì</span> Ïò§ÌîÑÏÖã 1px, <span class="kbd">Shift</span>+Î∞©Ìñ•ÌÇ§ 10px, <span class="kbd">Alt</span>+Î∞©Ìñ•ÌÇ§ 0.25px(ÌîºÎ≤ó Ï°∞Ï†à Î™®ÎìúÏùº Îïå)<br/>
      <span class="kbd">P</span> ÌîºÎ≤ó Ï°∞Ï†à Î™®Îìú ÌÜ†Í∏Ä, <span class="kbd">R</span> Î¶¨ÏÖã
      <div id="status" class="mono" style="margin-top:10px;"></div>
      <div id="errors" class="err" style="margin-top:10px;"></div>
    </div>

    <div class="hint mono">
      Î°úÏª¨ ÏÑúÎ≤Ñ Îπ†Î•∏ Î∞©Î≤ï:
      <div class="pill">Python</div> <span class="mono">cd client</span> ÌõÑ <span class="mono">python -m http.server 8000</span><br/>
      Í∑∏Î¶¨Í≥† <span class="mono">http://localhost:8000/barrack_pivot_tuner_v2.html</span> Ïó¥Í∏∞
    </div>
  </div>

  <div class="canvasWrap">
    <canvas id="cv"></canvas>
    <div class="overlay mono" id="overlay"></div>
  </div>
</div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);
  const status = $("status");
  const errors = $("errors");
  const overlay = $("overlay");
  const cv = $("cv");
  const ctx = cv.getContext("2d");

  const atlasCandidates = [
    "js/atlas_tp.js",        // if tuner is placed inside client/
    "client/js/atlas_tp.js", // if tuner is placed at repo root
    "./js/atlas_tp.js",
    "./client/js/atlas_tp.js"
  ];

  let pivotMode = false;
  let atlasLoaded = false;

  function setError(msg) {
    errors.textContent = msg || "";
  }
  function setStatus(msg, ok=false) {
    status.innerHTML = ok ? `<span class="ok">${msg}</span>` : msg;
  }

  function loadScriptSequential(list, i=0) {
    $("atlasJsPick").innerHTML = "";
    list.forEach((p, idx) => {
      const opt = document.createElement("option");
      opt.value = p; opt.textContent = p;
      if (idx === i) opt.selected = true;
      $("atlasJsPick").appendChild(opt);
    });

    return new Promise((resolve, reject) => {
      if (i >= list.length) return reject(new Error("atlas_tp.js Î°úÎìú Ïã§Ìå®: Í≤ΩÎ°ú ÌõÑÎ≥¥ Ï†ÑÎ∂Ä Ïã§Ìå®"));
      const src = list[i];
      const s = document.createElement("script");
      s.src = src;
      s.defer = true;
      s.onload = () => resolve(src);
      s.onerror = () => loadScriptSequential(list, i+1).then(resolve).catch(reject);
      document.head.appendChild(s);
    });
  }

  function resize() {
    const dpr = window.devicePixelRatio || 1;
    const rect = cv.getBoundingClientRect();
    cv.width = Math.max(2, Math.floor(rect.width * dpr));
    cv.height = Math.max(2, Math.floor(rect.height * dpr));
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener("resize", resize);
  resize();

  // --- Minimal TP atlas loader (expects atlas_tp.js to define window.TPAtlas or similar)
  // We don't know your exact API, so we implement a tiny fallback:
  // - If atlas_tp.js defines window.tpAtlasLoad(jsonPath) we use it.
  // - Else we parse the TexturePacker JSON ourselves and draw via Image+frames.
  async function fetchJson(path) {
    const res = await fetch(path, { cache: "no-store" });
    if (!res.ok) throw new Error(`fetch Ïã§Ìå® ${path} (${res.status})`);
    return await res.json();
  }

  function guessBaseDir(jsonPath) {
    const i = jsonPath.lastIndexOf("/");
    return i >= 0 ? jsonPath.slice(0, i+1) : "";
  }

  async function loadTP(jsonPath) {
    // Try project-provided loader first
    if (typeof window.tpAtlasLoad === "function") {
      const atlas = await window.tpAtlasLoad(jsonPath);
      return { kind: "native", atlas };
    }
    // Fallback parse
    const data = await fetchJson(jsonPath);
    // TexturePacker can be {frames:{}} or {textures:[{frames:[]}]}
    let frames = [];
    let imageFile = null;

    if (data.textures && data.textures[0] && data.textures[0].frames) {
      frames = data.textures[0].frames;
      imageFile = data.textures[0].image;
    } else if (data.frames) {
      frames = Object.entries(data.frames).map(([filename, v]) => ({ filename, ...v }));
      imageFile = data.meta?.image || data.meta?.textureFileName || null;
    } else {
      throw new Error("TP json Ìè¨Îß∑ Ïù∏Ïãù Ïã§Ìå® (textures/frames ÏóÜÏùå)");
    }

    const base = guessBaseDir(jsonPath);
    const img = new Image();
    img.src = base + imageFile;
    await new Promise((res, rej) => { img.onload=res; img.onerror=() => rej(new Error(`Ïù¥ÎØ∏ÏßÄ Î°úÎìú Ïã§Ìå®: ${img.src}`)); });

    // normalize frame records
    const norm = frames.map(f => {
      const fr = f.frame || f.spriteSourceSize || f; // depends on format
      const frame = f.frame || f; // {x,y,w,h}
      const anchor = f.anchor || f.pivot || { x: 0.5, y: 0.5 };
      return {
        filename: f.filename,
        frame: { x: frame.x|0, y: frame.y|0, w: frame.w|0, h: frame.h|0 },
        anchor: { x: +anchor.x || 0.5, y: +anchor.y || 0.5 }
      };
    });

    return { kind: "fallback", img, frames: norm };
  }

  function getPaths() {
    return {
      idle: $("idlePath").value.trim(),
      const: $("constPath").value.trim(),
      dest: $("destPath").value.trim(),
    };
  }

  let atlases = { idle: null, const: null, dest: null };
  let current = null;

  function listFrames(atlasObj) {
    if (!atlasObj) return [];
    if (atlasObj.kind === "native") {
      // unknown API: try common patterns
      const a = atlasObj.atlas;
      if (Array.isArray(a.frames)) return a.frames.map(f => f.filename || f.name).filter(Boolean);
      if (a.textures?.[0]?.frames) return a.textures[0].frames.map(f => f.filename);
      if (a.frames && typeof a.frames === "object") return Object.keys(a.frames);
      return [];
    } else {
      return atlasObj.frames.map(f => f.filename);
    }
  }

  function pickFrame(atlasObj, name) {
    if (!atlasObj) return null;
    if (atlasObj.kind === "native") {
      const a = atlasObj.atlas;
      // we can't safely render without knowing API; fallback will handle drawing anyway.
      return { native: true, name };
    } else {
      return atlasObj.frames.find(f => f.filename === name) || null;
    }
  }

  function draw() {
    ctx.clearRect(0,0,cv.width,cv.height);
    const w = cv.getBoundingClientRect().width;
    const h = cv.getBoundingClientRect().height;

    // Draw reference 3x2 tile box (isometric-ish helper)
    const tileW = 120, tileH = 60;
    const tw = 3, th = 2;
    const cx = w * 0.55, cy = h * 0.58;

    ctx.save();
    ctx.translate(cx, cy);

    // footprint rhombus
    ctx.strokeStyle = "rgba(120,200,255,.7)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    const p0 = {x:0, y:0};
    const p1 = {x: tw*tileW/2, y: -tw*tileH/2};
    const p2 = {x: (tw-th)*tileW/2, y: -(tw+th)*tileH/2};
    const p3 = {x: -th*tileW/2, y: -(-th*tileH/2) - th*tileH/2}; // we'll compute simpler below
    // Simpler: corners from vectors
    const vx = {x: tileW/2, y: -tileH/2};
    const vy = {x: -tileW/2, y: -tileH/2};
    const A = {x:0,y:0};
    const B = {x: vx.x*tw, y: vx.y*tw};
    const D = {x: vy.x*th, y: vy.y*th};
    const C = {x: B.x + D.x, y: B.y + D.y};
    ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.lineTo(C.x,C.y); ctx.lineTo(D.x,D.y); ctx.closePath();
    ctx.stroke();

    // center mark
    ctx.fillStyle = "rgba(255,255,255,.75)";
    ctx.beginPath(); ctx.arc((B.x+D.x)/2, (B.y+D.y)/2, 4, 0, Math.PI*2); ctx.fill();

    // Draw sprite frame if possible
    const s = $("scale").valueAsNumber || 1.0;
    const offX = $("offX").valueAsNumber || 0;
    const offY = $("offY").valueAsNumber || 0;
    const pivX = +$("pivX").value || 0.5;
    const pivY = +$("pivY").value || 0.52;

    if (current && current.kind === "fallback") {
      const fname = $("frameSel").value;
      const fr = pickFrame(current, fname);
      if (fr) {
        const img = current.img;
        const fx = fr.frame.x, fy = fr.frame.y, fw = fr.frame.w, fh = fr.frame.h;
        const drawX = (B.x+D.x)/2 + offX - fw * pivX * s;
        const drawY = (B.y+D.y)/2 + offY - fh * pivY * s;
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(img, fx, fy, fw, fh, drawX, drawY, fw*s, fh*s);

        // pivot marker
        ctx.fillStyle = "rgba(255,120,120,.95)";
        ctx.beginPath(); ctx.arc(drawX + fw*s*pivX, drawY + fh*s*pivY, 4, 0, Math.PI*2); ctx.fill();
      }
    } else {
      // native mode: can't draw without knowing your atlas runtime; show hint
      ctx.fillStyle = "rgba(255,255,255,.75)";
      ctx.fillText("atlas_tp.js Î°úÎìúÎê®. ÌïòÏßÄÎßå TP Îü∞ÌÉÄÏûÑ APIÎ•º Î™ª Ï∞æÏïÑÏÑú fallback Î†åÎçîÎßå ÏßÄÏõêÌï®.", -320, 40);
    }

    ctx.restore();

    overlay.textContent =
`mode=${$("mode").value}  frame=${$("frameSel").value}
pivotMode=${pivotMode ? "ON" : "OFF (offset)"}
offX=${$("offX").value} offY=${$("offY").value}  scale=${$("scale").value}
pivX=${$("pivX").value} pivY=${$("pivY").value}`;
  }

  function refreshFrameList() {
    const mode = $("mode").value;
    const a = atlases[mode];
    const list = listFrames(a);
    $("frameSel").innerHTML = "";
    list.slice(0, 500).forEach(n => {
      const opt = document.createElement("option");
      opt.value = n; opt.textContent = n;
      $("frameSel").appendChild(opt);
    });
  }

  async function loadAll() {
    setError("");
    setStatus("atlas_tp.js Î°úÎìú ÏãúÎèÑÏ§ë...");
    const picked = $("atlasJsPick").value || atlasCandidates[0];

    // Load JS first (best effort)
    try {
      await loadScriptSequential(atlasCandidates, atlasCandidates.indexOf(picked) >= 0 ? atlasCandidates.indexOf(picked) : 0);
      atlasLoaded = true;
      setStatus("atlas_tp.js Î°úÎìú ÏÑ±Í≥µ ‚úÖ", true);
    } catch (e) {
      atlasLoaded = false;
      setStatus("atlas_tp.js Î°úÎìú Ïã§Ìå® (fallback Î†åÎçîÎßå ÏãúÎèÑ) ‚ö†Ô∏è");
    }

    // Load TP jsons via fetch (needs local server)
    const paths = getPaths();
    try {
      atlases.idle = await loadTP(paths.idle);
      atlases.const = await loadTP(paths.const);
      atlases.dest = await loadTP(paths.dest);
      setStatus("TP JSON/PNG Î°úÎìú ÏÑ±Í≥µ ‚úÖ (fetch OK)", true);
      refreshFrameList();
      draw();
    } catch (e) {
      setError(String(e && e.message ? e.message : e));
      setStatus("TP JSON/PNG Î°úÎìú Ïã§Ìå®. ÌååÏùº://Î°ú Ïó¥Î©¥ Ïã§Ìå®ÌïòÎäî Í≤å Ï†ïÏÉÅÏûÑ. Î°úÏª¨ ÏÑúÎ≤ÑÎ°ú Ïó¥Ïñ¥.", false);
      draw();
    }
  }

  // UI hooks
  ["idlePath","constPath","destPath","mode"].forEach(id => $(id).addEventListener("change", async () => {
    await loadAll();
  }));
  ["frameSel","offX","offY","pivX","pivY","scale"].forEach(id => $(id).addEventListener("input", draw));
  $("copyBtn").addEventListener("click", async () => {
    const payload = {
      mode: $("mode").value,
      frame: $("frameSel").value,
      offX: +$("offX").value || 0,
      offY: +$("offY").value || 0,
      pivX: +$("pivX").value || 0.5,
      pivY: +$("pivY").value || 0.52,
      scale: +$("scale").value || 1.0
    };
    console.log("[pivot-tuner] copy:", payload);
    try {
      await navigator.clipboard.writeText(JSON.stringify(payload, null, 2));
      setStatus("ÌÅ¥Î¶ΩÎ≥¥ÎìúÏóê Î≥µÏÇ¨Îê® ‚úÖ", true);
    } catch {
      setStatus("ÏΩòÏÜîÏóêÎßå Ï∂úÎ†•Îê® (ÌÅ¥Î¶ΩÎ≥¥Îìú Í∂åÌïú ÏóÜÏùå)", false);
    }
  });

  window.addEventListener("keydown", (e) => {
    const step = e.shiftKey ? 10 : 1;
    if (["ArrowLeft","ArrowRight","ArrowUp","ArrowDown","p","P","r","R"].includes(e.key)) e.preventDefault();

    if (e.key === "p" || e.key === "P") {
      pivotMode = !pivotMode;
      draw();
      return;
    }
    if (e.key === "r" || e.key === "R") {
      $("offX").value = 0; $("offY").value = 0;
      $("pivX").value = 0.50; $("pivY").value = 0.52;
      $("scale").value = 1.0;
      draw();
      return;
    }

    if (!["ArrowLeft","ArrowRight","ArrowUp","ArrowDown"].includes(e.key)) return;

    if (!pivotMode) {
      let x = +$("offX").value || 0;
      let y = +$("offY").value || 0;
      if (e.key === "ArrowLeft") x -= step;
      if (e.key === "ArrowRight") x += step;
      if (e.key === "ArrowUp") y -= step;
      if (e.key === "ArrowDown") y += step;
      $("offX").value = x;
      $("offY").value = y;
    } else {
      const pStep = e.altKey ? 0.0025 : 0.01;
      let x = +$("pivX").value || 0.5;
      let y = +$("pivY").value || 0.52;
      if (e.key === "ArrowLeft") x -= pStep;
      if (e.key === "ArrowRight") x += pStep;
      if (e.key === "ArrowUp") y -= pStep;
      if (e.key === "ArrowDown") y += pStep;
      x = Math.max(0, Math.min(1, x));
      y = Math.max(0, Math.min(1, y));
      $("pivX").value = x.toFixed(4);
      $("pivY").value = y.toFixed(4);
    }
    draw();
  }, { passive:false });

  // kick
  loadAll();
  setInterval(draw, 1000/30);
})();
</script>
</body>
</html>
