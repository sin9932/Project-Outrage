<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Barrack Pivot Tuner v4</title>
  <style>
    :root { color-scheme: dark; }
    html, body { margin:0; height:100%; background:#0b0f16; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial; }
    #wrap { display:flex; height:100%; }
    #panel {
      width: 360px; min-width: 360px; max-width: 360px;
      padding: 12px; box-sizing:border-box;
      border-right: 1px solid rgba(255,255,255,0.08);
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      overflow:auto;
    }
    h1 { font-size: 16px; margin: 0 0 10px; }
    .row { display:flex; gap:8px; align-items:center; margin:8px 0; }
    .row > * { flex:1; }
    label { font-size: 12px; opacity: 0.9; }
    input, select, button {
      width:100%;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      color:#e8eefc;
      padding: 8px 10px;
      border-radius: 10px;
      outline: none;
    }
    button { cursor:pointer; }
    button.primary { background: rgba(99, 165, 255, 0.22); border-color: rgba(99,165,255,0.35); }
    button.warn { background: rgba(255, 121, 121, 0.18); border-color: rgba(255,121,121,0.28); }
    .small { font-size: 12px; opacity:0.85; line-height:1.35; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size: 12px; }
    hr { border:none; border-top:1px solid rgba(255,255,255,0.08); margin: 12px 0; }
    #canvas { flex:1; display:block; width:100%; height:100%; }
    .pill {
      display:inline-block; padding: 3px 8px; border-radius:999px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      font-size: 11px; margin-right:6px;
    }
    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
    .grid3 { display:grid; grid-template-columns: 1fr 1fr 1fr; gap:8px; }
    .hint { opacity: 0.75; }
    .kbd { padding:2px 6px; border-radius:6px; border:1px solid rgba(255,255,255,0.12); background:rgba(255,255,255,0.05); font-size:11px; }
  </style>
</head>
<body>
<div id="wrap">
  <div id="panel">
    <h1>ğŸ—ï¸ Barrack Pivot Tuner v4</h1>
    <div class="small">
      ì´ê±´ â€œpngë§Œ ì¬ìƒâ€ì´ ì•„ë‹ˆë¼ <b>íƒ€ì¼(3Ã—2) ì˜¤ë²„ë ˆì´</b> ìœ„ì— ìŠ¤í”„ë¼ì´íŠ¸ë¥¼ ì–¹ê³ ,
      <b>pivot(ì•µì»¤)</b>ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ì¡°ì ˆí•´ì„œ <b>ìˆ˜ì¹˜</b>ë¥¼ ë½‘ëŠ” íˆ´ì´ì•¼.
      <br><span class="hint">ì¤‘ìš”: <span class="kbd">file:///</span>ë¡œ ì—´ë©´ fetchê°€ ê¼¬ì„. ë°˜ë“œì‹œ ë¡œì»¬ì„œë²„(ì˜ˆ: localhost)ë¡œ ì—´ì–´.</span>
    </div>

    <hr/>

    <div class="small">
      <span class="pill">ë¡œë“œ</span> ì•„ë˜ URLì€ ë„¤ê°€ ì¤€ ìµœì¢… ê²½ë¡œ ê¸°ì¤€ìœ¼ë¡œ ê¸°ë³¸ê°’ ë„£ì–´ë†¨ë‹¤.
    </div>

    <label>Base URL (ì„ íƒ, ë¹„ìš°ë©´ í˜„ì¬ origin)</label>
    <input id="baseUrl" placeholder="ì˜ˆ: http://localhost:5173" />

    <label style="margin-top:10px;">Idle JSON</label>
    <input id="idleUrl" value="/asset/sprite/const/normal/barrack/barrack_idle.json"/>

    <label style="margin-top:10px;">Const JSON</label>
    <input id="constUrl" value="/asset/sprite/const/const_anim/barrack/barrack_const.json"/>

    <label style="margin-top:10px;">Distruct JSON</label>
    <input id="distUrl" value="/asset/sprite/const/distruct/barrack/barrack_distruct.json"/>

    <div class="row">
      <button id="btnLoad" class="primary">JSON ë¡œë“œ</button>
      <button id="btnReset" class="warn">ë¦¬ì…‹</button>
    </div>

    <div id="status" class="small mono"></div>

    <hr/>

    <div class="grid2">
      <div>
        <label>ì„¸íŠ¸</label>
        <select id="setSel">
          <option value="idle">idle</option>
          <option value="const">const</option>
          <option value="dist">distruct</option>
        </select>
      </div>
      <div>
        <label>í”„ë ˆì„</label>
        <select id="frameSel"></select>
      </div>
    </div>

    <div class="grid3" style="margin-top:8px;">
      <button id="btnPlay">ì¬ìƒ</button>
      <button id="btnPause">ì •ì§€</button>
      <button id="btnStep">1í”„ë ˆì„</button>
    </div>

    <div class="grid2" style="margin-top:8px;">
      <div>
        <label>FPS</label>
        <input id="fps" type="number" value="12" min="1" max="60"/>
      </div>
      <div>
        <label>ìŠ¤ì¼€ì¼</label>
        <input id="scale" type="number" value="0.55" step="0.01" min="0.05" max="3"/>
      </div>
    </div>

    <hr/>

    <div class="small">
      <span class="pill">íƒ€ì¼ ì˜¤ë²„ë ˆì´</span>
      3Ã—2 footprintë¥¼ ë³´ë©´ì„œ pivot ë§ì¶”ëŠ” ìš©ë„.
    </div>

    <div class="grid2">
      <div>
        <label>tileW</label>
        <input id="tileW" type="number" value="64" min="8" max="512"/>
      </div>
      <div>
        <label>tileH</label>
        <input id="tileH" type="number" value="32" min="4" max="512"/>
      </div>
    </div>

    <div class="grid2" style="margin-top:8px;">
      <div>
        <label>footprint W</label>
        <input id="footW" type="number" value="3" min="1" max="10"/>
      </div>
      <div>
        <label>footH</label>
        <input id="footH" type="number" value="2" min="1" max="10"/>
      </div>
    </div>

    <div class="row">
      <button id="btnCenterToFoot" class="primary">pivotì„ footprint ì¤‘ì‹¬ìœ¼ë¡œ</button>
    </div>

    <hr/>

    <div class="small">
      <span class="pill">Pivot ì¡°ì ˆ</span>
      <span class="hint">ë‹¨ì¶•í‚¤: <span class="kbd">â†â†‘â†“â†’</span> nudge, <span class="kbd">Shift</span> = 10ë°°</span>
    </div>

    <label>pivot X (normalized 0..1)</label>
    <input id="pivotX" type="range" min="0" max="1" step="0.0005" value="0.5"/>
    <div class="row">
      <button id="nx">X -</button><button id="px">X +</button>
    </div>

    <label>pivot Y (normalized 0..1)</label>
    <input id="pivotY" type="range" min="0" max="1" step="0.0005" value="0.52"/>
    <div class="row">
      <button id="ny">Y -</button><button id="py">Y +</button>
    </div>

    <div class="small mono" id="readout"></div>

    <hr/>

    <div class="small hint">
      <b>ê²°ë¡ ë§Œ</b>: ì—¬ê¸°ì„œ ì›í•˜ëŠ” í”„ë ˆì„ì„ ê³¨ë¼ì„œ pivot ë§ì¶”ê³ , ë‚˜ì˜¨ ê°’ì„
      ë„¤ jsonì˜ <span class="mono">anchor: {x,y}</span>ë¡œ ì˜®ê¸°ë©´ ë.
    </div>
  </div>

  <canvas id="canvas"></canvas>
</div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  const canvas = $("canvas");
  const ctx = canvas.getContext("2d", { alpha: true });

  const state = {
    ready: false,
    playing: true,
    t: 0,
    frameIdx: 0,
    sets: {
      idle: null,
      const: null,
      dist: null,
    },
    images: new Map(), // url -> HTMLImageElement
    framesBySet: {
      idle: [],
      const: [],
      dist: [],
    },
    selectedSet: "idle",
    selectedFrameKey: null,
    // pivot normalized
    pivotX: 0.5,
    pivotY: 0.52,
  };

  function resize() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(canvas.clientWidth * dpr);
    canvas.height = Math.floor(canvas.clientHeight * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener("resize", resize);
  resize();

  function absUrl(path) {
    const base = $("baseUrl").value.trim();
    if (!path) return path;
    if (path.startsWith("http://") || path.startsWith("https://")) return path;
    const origin = base || window.location.origin;
    if (path.startsWith("/")) return origin + path;
    return origin + "/" + path;
  }

  async function fetchJson(url) {
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText} :: ${url}`);
    return await res.json();
  }

  function inferImageUrl(json, jsonUrl) {
    // TexturePacker style: json.textures[0].image
    // Use same folder as jsonUrl
    const imgName = json?.textures?.[0]?.image;
    if (!imgName) return null;
    const base = jsonUrl.split("/").slice(0, -1).join("/");
    return absUrl(base + "/" + imgName);
  }

  function listFrameKeys(json) {
    // json.textures[0].frames is array of objects with filename
    const frames = json?.textures?.[0]?.frames || [];
    const keys = frames.map(f => f.filename).filter(Boolean);
    return keys;
  }

  function getFrame(json, key) {
    const frames = json?.textures?.[0]?.frames || [];
    return frames.find(f => f.filename === key) || null;
  }

  function getSourceSize(frameObj) {
    // prefer sourceSize; fall back to json.textures[0].size
    if (frameObj && frameObj.sourceSize) return frameObj.sourceSize;
    return null;
  }

  async function loadImage(url) {
    if (state.images.has(url)) return state.images.get(url);
    const img = new Image();
    img.crossOrigin = "anonymous";
    const p = new Promise((resolve, reject) => {
      img.onload = () => resolve(img);
      img.onerror = (e) => reject(new Error("ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨: " + url));
    });
    img.src = url;
    const loaded = await p;
    state.images.set(url, loaded);
    return loaded;
  }

  function rebuildFrameDropdown() {
    const set = state.selectedSet;
    const sel = $("frameSel");
    sel.innerHTML = "";
    const keys = state.framesBySet[set] || [];
    for (const k of keys) {
      const opt = document.createElement("option");
      opt.value = k;
      opt.textContent = k;
      sel.appendChild(opt);
    }
    state.selectedFrameKey = keys[0] || null;
    sel.value = state.selectedFrameKey || "";
  }

  function status(msg) { $("status").textContent = msg; }

  async function onLoad() {
    try {
      status("ë¡œë”© ì¤‘...");
      state.ready = false;

      const idleUrl = absUrl($("idleUrl").value.trim());
      const constUrl = absUrl($("constUrl").value.trim());
      const distUrl = absUrl($("distUrl").value.trim());

      const [idleJ, constJ, distJ] = await Promise.all([
        fetchJson(idleUrl),
        fetchJson(constUrl),
        fetchJson(distUrl),
      ]);

      state.sets.idle = { json: idleJ, jsonUrl: idleUrl, imgUrl: inferImageUrl(idleJ, idleUrl), img: null };
      state.sets.const = { json: constJ, jsonUrl: constUrl, imgUrl: inferImageUrl(constJ, constUrl), img: null };
      state.sets.dist = { json: distJ, jsonUrl: distUrl, imgUrl: inferImageUrl(distJ, distUrl), img: null };

      // images
      for (const k of ["idle","const","dist"]) {
        const s = state.sets[k];
        if (!s.imgUrl) throw new Error(`${k} jsonì— textures[0].image ì—†ìŒ`);
        s.img = await loadImage(s.imgUrl);
        state.framesBySet[k] = listFrameKeys(s.json);
      }

      state.selectedSet = $("setSel").value;
      rebuildFrameDropdown();

      state.ready = true;
      status("âœ… ë¡œë“œ ì™„ë£Œ. í”„ë ˆì„ ì„ íƒí•˜ê³  pivot ë§ì¶°ë¼.");
    } catch (e) {
      console.error(e);
      status("âŒ " + (e?.message || e));
    }
  }

  function reset() {
    state.t = 0; state.frameIdx = 0;
    state.pivotX = 0.5; state.pivotY = 0.52;
    $("pivotX").value = String(state.pivotX);
    $("pivotY").value = String(state.pivotY);
    status("ë¦¬ì…‹ ì™„ë£Œ");
  }

  function nudge(dx, dy, mult=1) {
    const step = 0.0005 * mult;
    state.pivotX = Math.min(1, Math.max(0, state.pivotX + dx*step));
    state.pivotY = Math.min(1, Math.max(0, state.pivotY + dy*step));
    $("pivotX").value = String(state.pivotX);
    $("pivotY").value = String(state.pivotY);
  }

  function drawIsoFootprint(cx, cy, tileW, tileH, w, h) {
    // draw outline + internal tile grid for (w x h) footprint in isometric
    // iso tile corners relative to tileW/tileH.
    // Convert grid (i,j) to screen: x = (i-j)*tileW/2, y = (i+j)*tileH/2
    ctx.save();
    ctx.translate(cx, cy);

    // draw tiles
    ctx.lineWidth = 1;
    ctx.strokeStyle = "rgba(120,200,255,0.35)";
    ctx.fillStyle = "rgba(120,200,255,0.06)";
    for (let i=0;i<w;i++){
      for (let j=0;j<h;j++){
        const x = (i-j) * (tileW/2);
        const y = (i+j) * (tileH/2);
        ctx.beginPath();
        ctx.moveTo(x, y - tileH/2);
        ctx.lineTo(x + tileW/2, y);
        ctx.lineTo(x, y + tileH/2);
        ctx.lineTo(x - tileW/2, y);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
      }
    }

    // outline footprint perimeter (a bigger diamond-ish shape)
    // perimeter corners in grid:
    // top: (0,0) top vertex
    // right: (w-1,0) rightmost tile right vertex, etc
    const top = {x: 0, y: -tileH/2};
    const right = {x: (w-1)*(tileW/2) + tileW/2, y: (w-1)*(tileH/2)};
    const bottom = {x: (w-1 - (h-1))*(tileW/2), y: (w-1 + (h-1))*(tileH/2) + tileH/2};
    const left = {x: -(h-1)*(tileW/2) - tileW/2, y: (h-1)*(tileH/2)};

    ctx.strokeStyle = "rgba(255,255,255,0.55)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(top.x, top.y);
    ctx.lineTo(right.x, right.y);
    ctx.lineTo(bottom.x, bottom.y);
    ctx.lineTo(left.x, left.y);
    ctx.closePath();
    ctx.stroke();

    // center cross
    ctx.strokeStyle = "rgba(255,255,255,0.55)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-10,0); ctx.lineTo(10,0);
    ctx.moveTo(0,-10); ctx.lineTo(0,10);
    ctx.stroke();

    ctx.restore();
  }

  function drawSpriteAtPivot(setKey, frameKey, cx, cy, scale) {
    const s = state.sets[setKey];
    if (!s) return;

    const frameObj = getFrame(s.json, frameKey);
    if (!frameObj) return;

    const img = s.img;
    const fr = frameObj.frame; // {x,y,w,h}
    const src = frameObj.sourceSize || { w: fr.w, h: fr.h };
    const sss = frameObj.spriteSourceSize || { x:0, y:0, w:fr.w, h:fr.h };

    // pivot normalized is relative to sourceSize (same as TexturePacker anchor)
    const px = state.pivotX * src.w;
    const py = state.pivotY * src.h;

    // We want pivot point on screen at (cx, cy)
    // The drawn sprite rect (source canvas) has top-left at (-px, -py)
    // But atlas provides trimmed sprite placed at spriteSourceSize inside source.
    // So trimmed top-left relative to source top-left is (sss.x, sss.y).
    // Therefore, trimmed top-left relative to pivot is (sss.x - px, sss.y - py).
    const drawX = cx + (sss.x - px) * scale;
    const drawY = cy + (sss.y - py) * scale;
    const drawW = fr.w * scale;
    const drawH = fr.h * scale;

    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(img, fr.x, fr.y, fr.w, fr.h, drawX, drawY, drawW, drawH);

    // pivot marker
    ctx.save();
    ctx.strokeStyle = "rgba(255,120,120,0.95)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx, cy, 6, 0, Math.PI*2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(cx-12, cy); ctx.lineTo(cx+12, cy);
    ctx.moveTo(cx, cy-12); ctx.lineTo(cx, cy+12);
    ctx.stroke();
    ctx.restore();

    // readout
    $("readout").textContent =
      `set=${setKey}\nframe=${frameKey}\n` +
      `sourceSize=${src.w}x${src.h}\n` +
      `pivot(normalized) x=${state.pivotX.toFixed(4)} y=${state.pivotY.toFixed(4)}\n` +
      `pivot(px) x=${px.toFixed(1)} y=${py.toFixed(1)}\n` +
      `trim(frame) ${fr.w}x${fr.h} @ (${fr.x},${fr.y})\n` +
      `spriteSourceSize x=${sss.x} y=${sss.y} w=${sss.w} h=${sss.h}\n` +
      `ğŸ’¡ ì´ ê°’ ê·¸ëŒ€ë¡œ json anchorì— ë„£ì–´: { "x": ${state.pivotX.toFixed(4)}, "y": ${state.pivotY.toFixed(4)} }`;
  }

  function centerPivotToFootprint() {
    // put pivot marker at footprint center in screen space:
    // We don't know the "correct" pivot automatically; this button just sets the marker (pivot) to typical baseline:
    // x = 0.5; y = 0.52 (common for these assets) but also let user tweak tileW/H
    // We'll keep x=0.5 and y=0.52 as default; users still tweak.
    state.pivotX = 0.5;
    state.pivotY = 0.52;
    $("pivotX").value = String(state.pivotX);
    $("pivotY").value = String(state.pivotY);
  }

  function tick(dt) {
    if (!state.ready) return;
    if (!state.playing) return;

    const fps = Math.max(1, Math.min(60, parseFloat($("fps").value || "12")));
    state.t += dt;
    const frameTime = 1 / fps;
    while (state.t >= frameTime) {
      state.t -= frameTime;
      state.frameIdx++;
    }
  }

  function render() {
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;

    // background
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = "#0b0f16";
    ctx.fillRect(0,0,w,h);

    // horizon-ish vignette
    const g = ctx.createRadialGradient(w*0.5,h*0.55, 10, w*0.5,h*0.55, Math.max(w,h)*0.9);
    g.addColorStop(0, "rgba(255,255,255,0.06)");
    g.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    if (!state.ready) {
      ctx.fillStyle = "rgba(255,255,255,0.75)";
      ctx.font = "16px system-ui";
      ctx.fillText("ì™¼ìª½ì—ì„œ JSON ë¡œë“œ ëˆŒëŸ¬ë¼.", 24, 40);
      return;
    }

    const tileW = parseFloat($("tileW").value || "64");
    const tileH = parseFloat($("tileH").value || "32");
    const footW = parseInt($("footW").value || "3", 10);
    const footH = parseInt($("footH").value || "2", 10);
    const scale = parseFloat($("scale").value || "0.55");

    const cx = w * 0.52;
    const cy = h * 0.62;

    // footprint
    drawIsoFootprint(cx, cy, tileW, tileH, footW, footH);

    // choose current frame
    const setKey = state.selectedSet;
    const keys = state.framesBySet[setKey] || [];
    if (!keys.length) return;

    const selected = state.selectedFrameKey || keys[0];

    // if playing, advance frame index within list
    let frameKey = selected;
    if (state.playing) {
      frameKey = keys[state.frameIdx % keys.length];
      $("frameSel").value = frameKey;
      state.selectedFrameKey = frameKey;
    }

    drawSpriteAtPivot(setKey, frameKey, cx, cy, scale);

    // caption
    ctx.fillStyle = "rgba(255,255,255,0.72)";
    ctx.font = "12px ui-monospace, monospace";
    ctx.fillText("footprint center (white) / pivot marker (red)", 18, h-18);
  }

  let last = performance.now();
  function loop(now) {
    const dt = (now - last) / 1000;
    last = now;
    tick(dt);
    render();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // UI wiring
  $("btnLoad").addEventListener("click", onLoad);
  $("btnReset").addEventListener("click", reset);

  $("setSel").addEventListener("change", (e) => {
    state.selectedSet = e.target.value;
    state.frameIdx = 0; state.t = 0;
    state.playing = false; $("btnPlay").textContent = "ì¬ìƒ";
    rebuildFrameDropdown();
  });

  $("frameSel").addEventListener("change", (e) => {
    state.selectedFrameKey = e.target.value;
    state.playing = false;
  });

  $("btnPlay").addEventListener("click", () => { state.playing = true; });
  $("btnPause").addEventListener("click", () => { state.playing = false; });
  $("btnStep").addEventListener("click", () => { state.playing = false; state.frameIdx++; });

  $("pivotX").addEventListener("input", (e) => { state.pivotX = parseFloat(e.target.value); });
  $("pivotY").addEventListener("input", (e) => { state.pivotY = parseFloat(e.target.value); });

  $("nx").addEventListener("click", () => nudge(-1, 0, 1));
  $("px").addEventListener("click", () => nudge(+1, 0, 1));
  $("ny").addEventListener("click", () => nudge(0, -1, 1));
  $("py").addEventListener("click", () => nudge(0, +1, 1));

  $("btnCenterToFoot").addEventListener("click", centerPivotToFootprint);

  window.addEventListener("keydown", (e) => {
    const mult = e.shiftKey ? 10 : 1;
    if (e.key === "ArrowLeft") { nudge(-1,0,mult); e.preventDefault(); }
    if (e.key === "ArrowRight") { nudge(+1,0,mult); e.preventDefault(); }
    if (e.key === "ArrowUp") { nudge(0,-1,mult); e.preventDefault(); }
    if (e.key === "ArrowDown") { nudge(0,+1,mult); e.preventDefault(); }
  });

})();
</script>
</body>
</html>
