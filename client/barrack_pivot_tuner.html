<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Pivot Tuner v9 (ingame match + pan/zoom)</title>
<style>
  :root{
    --bg:#0b0f16;
    --panel:#0f1724;
    --panel2:#0b1220;
    --txt:#d7e1ff;
    --muted:#9fb0d9;
    --line:#22304d;
    --accent:#4fe3a0;
    --warn:#ffcc66;
    --err:#ff6b6b;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--txt);font:13px/1.3 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; height:100vh; overflow:hidden;}
  .wrap{display:flex;height:100vh;}
  .left{width:360px;min-width:320px;max-width:420px;background:linear-gradient(180deg,var(--panel),var(--panel2));border-right:1px solid var(--line);overflow:auto;padding:12px;}
  .right{flex:1;position:relative;min-width:0;}
  .row{display:flex;gap:8px;align-items:center;margin:6px 0;}
  .col{display:flex;flex-direction:column;gap:6px;}
  .grid2{display:grid;grid-template-columns:1fr 1fr;gap:8px;}
  label{color:var(--muted);font-size:12px;}
  input,select,button,textarea{
    width:100%;
    background:#0b1220;
    color:var(--txt);
    border:1px solid #1b2946;
    border-radius:8px;
    padding:8px 10px;
    outline:none;
  }
  input[type="number"]{padding-right:6px}
  button{cursor:pointer;background:#0e1a32;}
  button:hover{border-color:#2a3a66}
  button.primary{background:#112a2a;border-color:#1f6b55}
  button.primary:hover{border-color:#3ee6a6}
  button.warn{background:#2a1f11;border-color:#6b4a1f}
  .chips{display:flex;gap:6px;flex-wrap:wrap;margin:6px 0 10px;}
  .chip{padding:6px 8px;border-radius:999px;border:1px solid #22304d;background:#0b1220;color:var(--txt);cursor:pointer;font-size:12px;}
  .chip:hover{border-color:#3ee6a6}
  .status{white-space:pre-wrap;padding:8px 10px;border-radius:10px;border:1px solid #1b2946;background:#0b1220;color:var(--muted);margin-top:8px;}
  .status.err{border-color:#3b1b1b;color:#ffd0d0}
  .status.ok{border-color:#1f6b55;color:#c9ffe9}
  .hint{color:var(--muted);font-size:12px;margin-top:8px}
  textarea{height:76px;resize:vertical;}
  canvas{position:absolute;inset:0;width:100%;height:100%;display:block;}
  .topbar{position:absolute;left:12px;top:10px;display:flex;gap:10px;align-items:center;color:var(--muted);font-size:12px;background:rgba(11,18,32,.55);padding:6px 10px;border:1px solid rgba(34,48,77,.6);border-radius:10px;backdrop-filter:blur(8px)}
  .kbd{border:1px solid rgba(34,48,77,.8);border-bottom-color:rgba(34,48,77,.4);padding:1px 6px;border-radius:6px;color:var(--txt);font-size:11px;background:rgba(15,23,36,.35)}
  .check{display:flex;align-items:center;gap:8px;margin:6px 0;}
  .check input{width:auto}
  .mini{margin-top:8px;display:none}
  .mini.on{display:block}
  .mini pre{margin:0;background:#0b1220;border:1px solid #1b2946;border-radius:10px;padding:8px 10px;color:var(--muted);overflow:auto;max-height:160px}
</style>
</head>
<body>
<div class="wrap">
  <div class="left">
    <div style="font-weight:700;font-size:14px;">Pivot Tuner v9</div>
    <div class="hint">목표: <b>인게임 좌표계(iso 64/32, baseOffsetY=0.22)</b> 그대로 + <b>팬/줌</b>으로 큰 footprint도 보기 편하게.</div>

    <div class="row" style="margin-top:10px;">
      <div class="col" style="flex:1">
        <label>Atlas JSON URL</label>
        <input id="atlasUrl" placeholder="asset/sprite/const/normal/barrack/barrack_idle.json"/>
        <div class="hint" id="resolvedLinks">Resolved URLs will appear here after Load.</div>
      </div>
    </div>

    <div class="chips">
      <div class="chip" id="chipIdle">barrack idle</div>
      <div class="chip" id="chipConst">barrack const</div>
      <div class="chip" id="chipDist">barrack dist</div>
    </div>

    <div class="row">
      <button id="btnLoad" class="primary">Load</button>
      <button id="btnReload">Reload</button>
    </div>

    <div id="status" class="status">Ready.</div>

    <hr style="border:0;border-top:1px solid var(--line);margin:12px 0"/>

    <div class="grid2">
      <div class="col">
        <label>Set (prefix)</label>
        <input id="prefix" placeholder="barrack_idle / barrack_con_complete / barrack_distruction"/>
      </div>
      <div class="col">
        <label>Frame</label>
        <select id="frameSel"></select>
      </div>
    </div>

    <div class="grid2">
      <div class="col">
        <label>FPS</label>
        <input id="fps" type="number" step="1" min="1" max="60" value="20"/>
      </div>
      <div class="col">
        <label>Sprite scale (view)</label>
        <input id="spriteScale" type="number" step="0.01" min="0.02" max="2" value="0.14"/>
      </div>
    </div>

    <div class="row">
      <button id="btnPlay">Play</button>
      <button id="btnPause">Pause</button>
      <button id="btnStep">1 Frame</button>
    </div>

    <label>Pivot X (normalized 0..1)</label>
    <div class="grid2">
      <button id="btnXMinus">X-</button>
      <button id="btnXPlus">X+</button>
    </div>
    <input id="pivotX" type="range" min="0" max="1" step="0.0001" value="0.5"/>

    <label>Pivot Y (normalized 0..1)</label>
    <div class="grid2">
      <button id="btnYMinus">Y-</button>
      <button id="btnYPlus">Y+</button>
    </div>
    <input id="pivotY" type="range" min="0" max="1" step="0.0001" value="0.5"/>

    <div class="row">
      <button id="btnApplyPrefix" class="primary">Apply pivot to prefix</button>
      <button id="btnDownload">Download patched JSON</button>
    </div>

    <label>Copy/paste (JSON anchor)</label>
    <textarea id="out" readonly></textarea>

    <hr style="border:0;border-top:1px solid var(--line);margin:12px 0"/>

    <div style="font-weight:700;margin-bottom:6px;">Ingame coords</div>

    <div class="grid2">
      <div class="col"><label>TILE</label><input id="tile" type="number" value="110"/></div>
      <div class="col"><label>Cam zoom (game)</label><input id="camZoom" type="number" step="0.01" value="1"/></div>
      <div class="col"><label>Cam tileX</label><input id="camX" type="number" step="0.01" value="0"/></div>
      <div class="col"><label>Cam tileY</label><input id="camY" type="number" step="0.01" value="0"/></div>
    </div>

    <div class="grid2">
      <div class="col"><label>Building tx</label><input id="btx" type="number" step="1" value="0"/></div>
      <div class="col"><label>Building ty</label><input id="bty" type="number" step="1" value="0"/></div>
      <div class="col"><label>Footprint W (tw)</label><input id="tw" type="number" step="1" min="1" value="3"/></div>
      <div class="col"><label>Footprint H (th)</label><input id="th" type="number" step="1" min="1" value="2"/></div>
    </div>

    <div class="grid2">
      <div class="col">
        <label>Anchor mode</label>
        <select id="anchorMode">
          <option value="center">center (footprint center)</option>
          <option value="south">south edge center</option>
          <option value="sw">south-west corner</option>
        </select>
      </div>
      <div class="col">
        <label>BaseOffsetY ratio</label>
        <input id="baseYRatio" type="number" step="0.01" value="0.22"/>
      </div>
    </div>

    <div style="font-weight:700;margin:10px 0 6px;">View (pan/zoom)</div>

    <div class="grid2">
      <div class="col"><label>View zoom</label><input id="viewZoom" type="number" step="0.05" value="1"/></div>
      <div class="col"><label>Grid span (tiles)</label><input id="gridSpan" type="number" step="1" min="6" value="30"/></div>
    </div>

    <div class="row">
      <button id="btnResetView">Reset view</button>
      <button id="btnFit">Fit to footprint</button>
    </div>

    <div class="check"><input id="showGrid" type="checkbox" checked/><label for="showGrid" style="margin:0">Grid</label></div>
    <div class="check"><input id="showFoot" type="checkbox" checked/><label for="showFoot" style="margin:0">Footprint (exact)</label></div>
    <div class="check"><input id="showAxis" type="checkbox" checked/><label for="showAxis" style="margin:0">Axis</label></div>
    <div class="check"><input id="showBounds" type="checkbox"/><label for="showBounds" style="margin:0">Frame bbox</label></div>

    <div class="hint">
      조작: <span class="kbd">드래그</span> 팬, <span class="kbd">휠</span> 줌, <span class="kbd">더블클릭</span> Fit.<br/>
      ※ 인게임 1:1 확인은 <b>Cam zoom=1</b> + <b>View zoom=1</b>에서 보면 됨. (View zoom은 “보기용”)
    </div>

    <div class="mini" id="mini">
      <div style="font-weight:700;margin:8px 0 6px;">Debug</div>
      <pre id="dbg"></pre>
    </div>
  </div>

  <div class="right">
    <div class="topbar" id="topbar">
      <span id="topInfo">canvas</span>
      <span class="kbd">drag</span><span class="kbd">wheel</span><span class="kbd">dblclick</span>
    </div>
    <canvas id="cv"></canvas>
  </div>
</div>

<script>
'use strict';

// ===== helpers
const $ = (id)=>document.getElementById(id);
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const dirname=(u)=>u.replace(/[#?].*$/,'').replace(/\/[^\/]*$/,'/') ;

// ===== state
let atlasData=null;
let basePath='';
let textures=[];
let frames=[]; // unified [{name, tex, rect:{x,y,w,h}, ss:{x,y,w,h}, source:{w,h}, anchor:{x,y}, rawRef}]
let cur=0;
let playing=false;
let lastT=0;

const cv=$('cv');
const ctx=cv.getContext('2d');

let dpr=1;

// view pan/zoom (screen space)
let panX=0, panY=0;
let isPanning=false;
let panStart=null;

// ===== canvas resize (robust)
function resizeCanvas(){
  const r=cv.getBoundingClientRect();
  dpr=window.devicePixelRatio||1;
  cv.width=Math.max(1,Math.floor(r.width*dpr));
  cv.height=Math.max(1,Math.floor(r.height*dpr));
}
const ro = new ResizeObserver(()=>{ resizeCanvas(); });
ro.observe(document.querySelector('.right'));
window.addEventListener('resize', resizeCanvas);
setTimeout(resizeCanvas, 0);

// ===== status
function setStatus(msg, kind=''){
  const el=$('status');
  el.textContent=msg;
  el.className='status' + (kind?(' '+kind):'');
}

// ===== atlas parsing (supports textures[] or normal TP json)
function parseTP(json){
  let texList=[];
  let unified=[];
  // texturepacker multiatlas: {textures:[{image,frames:{...}}]}
  if(Array.isArray(json.textures)){
    texList=json.textures.map(t=>({image:t.image, frames:t.frames||{}}));
  }else{
    // single: {meta:{image}, frames:{...} or frames:[...]}
    const img = json.meta?.image || json.image || json.meta?.imageName || null;
    if(!img && !json.frames){ throw new Error('Unknown TP json format (no textures[], no frames)'); }
    let framesObj = json.frames;
    // convert frames array->object
    if(Array.isArray(framesObj)){
      const obj={};
      for(const f of framesObj){
        if(!f.filename) continue;
        obj[f.filename]=f;
      }
      framesObj=obj;
    }
    texList=[{image: json.meta?.image || json.meta?.Image || json.image || 'atlas.png', frames: framesObj||{}}];
  }

  // normalize frames into unified list
  for(let ti=0; ti<texList.length; ti++){
    const t=texList[ti];
    const fr=t.frames||{};
    for(const [name, data] of Object.entries(fr)){
      const frame=data.frame || data; // frame: {x,y,w,h}
      const ss=data.spriteSourceSize || data.spriteSource || {x:0,y:0,w:frame.w||frame.width||0,h:frame.h||frame.height||0};
      const source=data.sourceSize || data.source || {w:data.sourceSize?.w||data.sourceSize?.width||frame.w||0,h:data.sourceSize?.h||data.sourceSize?.height||frame.h||0};
      const w = frame.w ?? frame.width;
      const h = frame.h ?? frame.height;
      unified.push({
        name,
        tex: ti,
        rect:{x:frame.x, y:frame.y, w, h},
        ss:{x:ss.x||0, y:ss.y||0, w:ss.w??ss.width??w, h:ss.h??ss.height??h},
        source:{w:source.w??source.width??(w), h:source.h??source.height??(h)},
        rotated: !!data.rotated,
        anchor: data.anchor ? {x:data.anchor.x, y:data.anchor.y} : {x:0.5,y:0.5},
        rawRef: data
      });
    }
  }
  // sort by trailing number if any
  unified.sort((a,b)=>{
    const na=a.name.match(/(\d+)(?=\D*$)/); const nb=b.name.match(/(\d+)(?=\D*$)/);
    if(na && nb) return (parseInt(na[1])-parseInt(nb[1])) || a.name.localeCompare(b.name);
    if(na && !nb) return -1;
    if(!na && nb) return 1;
    return a.name.localeCompare(b.name);
  });
  return {texList, unified};
}

async function fetchJson(url){
  const res = await fetch(url, {cache:'no-store'});
  const text = await res.text();
  if(!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);
  // quick HTML detection
  const t = text.trim();
  if(t.startsWith('<!doctype') || t.startsWith('<html') || t.includes('<head>')){
    throw new Error('Atlas URL returned HTML (경로 404/fallback 의심)');
  }
  try{
    return JSON.parse(text);
  }catch(e){
    throw new Error('JSON parse fail: ' + e.message);
  }
}

async function loadAtlas(){
  try{
    setStatus('Loading atlas JSON...');
    const input=$('atlasUrl').value.trim();
    if(!input){ setStatus('ERR: atlasUrl empty','err'); return; }

    // Resolve relative URLs against current page (works on subpaths like /Project-Outrage/)
    const atlasUrl = new URL(input, location.href).toString();

    // Show resolved links immediately
    $('resolvedLinks').innerHTML =
      `Atlas: <a href="${atlasUrl}" target="_blank" rel="noopener">open</a><br><span style="opacity:.9">${atlasUrl}</span>`;

    atlasData = await fetchJson(atlasUrl);

    // build textures list
    const parsed = parseTP(atlasData);

    // load images
    textures = [];
    for(let i=0;i<parsed.texList.length;i++){
      const imgName = parsed.texList[i].image;
      const img = new Image();
      const p = new Promise((resolve,reject)=>{
        img.onload=()=>resolve();
        img.onerror=()=>reject(new Error('image load fail: ' + imgName));
      });
      const imgUrl = new URL(imgName, atlasUrl).toString();
      img.src = imgUrl;
      await p;
      textures.push({img, name:imgName});
    }

    // List resolved texture URLs
    const texLinks = parsed.texList.map(t => {
      const u = new URL(t.image, atlasUrl).toString();
      return `Texture: <a href="${u}" target="_blank" rel="noopener">open</a><br><span style="opacity:.9">${u}</span>`;
    }).join('<br>');
    $('resolvedLinks').innerHTML += '<br>' + texLinks;

    frames = parsed.unified;
    // default prefix: first frame prefix if empty
    if(!$('prefix').value.trim() && frames.length){
      const f0=frames[0].name;
      const m=f0.match(/^(.*?)(\d+)?\.png$/i);
      $('prefix').value = m ? m[1] : f0.replace(/\.png$/i,'');
    }
    rebuildFrameSelect();
    cur=0;
    playing=false;
    lastT=0;
    syncPivotFromFrame();
    updateOutput();
    setStatus(`Loaded: ${frames.length} frames, ${textures.length} texture(s).`,'ok');
  }catch(e){
    setStatus('Load failed: ' + e.message,'err');
    console.error(e);
  }
}

function rebuildFrameSelect(){
  const prefix=$('prefix').value.trim();
  const sel=$('frameSel');
  sel.innerHTML='';
  const list = frames.filter(f=>!prefix || f.name.startsWith(prefix));
  if(!list.length && frames.length){
    // fallback: show all
    for(const f of frames){ 
      const opt=document.createElement('option');
      opt.value=f.name; opt.textContent=f.name;
      sel.appendChild(opt);
    }
  }else{
    for(const f of list){
      const opt=document.createElement('option');
      opt.value=f.name; opt.textContent=f.name;
      sel.appendChild(opt);
    }
  }
  if(sel.options.length) sel.selectedIndex=0;
}

function getCurrentFrame(){
  const name=$('frameSel').value;
  if(!name) return frames[cur]||null;
  return frames.find(f=>f.name===name) || frames[cur] || null;
}

function syncPivotFromFrame(){
  const f=getCurrentFrame();
  if(!f) return;
  const ax = (f.anchor && typeof f.anchor.x === 'number') ? f.anchor.x : 0.5;
  const ay = (f.anchor && typeof f.anchor.y === 'number') ? f.anchor.y : 0.5;
  $('pivotX').value = clamp(ax,0,1);
  $('pivotY').value = clamp(ay,0,1);
  updateOutput();
}

// ===== ingame mapping
function isoParams(){
  const TILE=+($('tile').value||128);
  return {TILE, ISO_X:TILE/2, ISO_Y:TILE/4};
}
function worldToIso(wx, wy){
  const {TILE, ISO_X, ISO_Y} = isoParams();
  // Match game.js: worldToIso(wx,wy) = { x:(wx-wy)*(ISO_X/TILE), y:(wx+wy)*(ISO_Y/TILE) }
  return { x: (wx - wy) * (ISO_X / TILE), y: (wx + wy) * (ISO_Y / TILE) };
}
// Screen coords relative to baseOffset(), matching game.js worldToScreen() minus base.
function worldToScreen(wx, wy, cam){
  const iso = worldToIso(wx, wy);
  const camIso = worldToIso(cam.x, cam.y);
  return { x: (iso.x - camIso.x) * cam.zoom, y: (iso.y - camIso.y) * cam.zoom };
}
= isoParams();
  const x = (tileX - tileY) * ISO_X;
  const y = (tileX + tileY) * ISO_Y;
  return {x: x*cam.zoom, y: y*cam.zoom};
}
function getCam(){
  return {
    x: +($('camX').value||0),
    y: +($('camY').value||0),
    zoom: +($('camZoom').value||1)
  };
}
function baseOffset(){
  const w=cv.width/dpr, h=cv.height/dpr;
  const baseX=w*0.5;
  const baseY=h*(+($('baseYRatio').value||0.22));
  return {baseX, baseY};
}

// anchor point on footprint (in tile coords)
function anchorTile(tileX, tileY, tw, th, mode){
  // IMPORTANT: match game logic (buildingWorldFromTileOrigin): center is at tx+tw/2, ty+th/2 in tile units.
  if(mode==='center'){
    return {ax: tileX + (tw/2), ay: tileY + (th/2)};
  }
  if(mode==='south'){
    // bottom edge center (footprint boundary)
    return {ax: tileX + (tw/2), ay: tileY + (th)};
  }
  // south-west corner on boundary
  return {ax: tileX, ay: tileY + (th)};
}

// ===== drawing
function clear(){
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,cv.width,cv.height);
}

function drawGrid(cam, view){
  if(!$('showGrid').checked) return;
  const {ISO_X, ISO_Y} = isoParams();
  const span = clamp(+$('gridSpan').value||30, 6, 200);
  const w=cv.width/dpr, h=cv.height/dpr;
  const {baseX, baseY} = baseOffset();

  // draw around building origin (0,0) in tile coords (or around camera)
  const cx = +($('btx').value||0);
  const cy = +($('bty').value||0);

  ctx.save();
  ctx.scale(dpr,dpr);
  ctx.translate(view.panX + baseX, view.panY + baseY);
  ctx.scale(view.zoom, view.zoom);

  ctx.lineWidth = 1;
  ctx.strokeStyle = 'rgba(74,120,170,0.18)';

  // draw diamond grid lines (two families)
  // We'll draw diamonds by iterating tile points
  const halfX = ISO_X * cam.zoom;
  const halfY = ISO_Y * cam.zoom;

  const startX = cx - span;
  const endX   = cx + span;
  const startY = cy - span;
  const endY   = cy + span;

  // draw tiles as faint diamonds (fast enough for span<=60)
  const step = span>60 ? 2 : 1;
  for(let ty=startY; ty<=endY; ty+=step){
    for(let tx=startX; tx<=endX; tx+=step){
      const p = worldToScreen((tx+0.5)*TILE, (ty+0.5)*TILE, cam);
      const sx=p.x, sy=p.y;
      ctx.beginPath();
      ctx.moveTo(sx, sy - halfY);
      ctx.lineTo(sx + halfX, sy);
      ctx.lineTo(sx, sy + halfY);
      ctx.lineTo(sx - halfX, sy);
      ctx.closePath();
      ctx.stroke();
    }
  }

  ctx.restore();
}

function drawFootprintExact(cam, view){
  if(!$('showFoot').checked) return;
  const tw = Math.max(1, parseInt($('tw').value||3,10));
  const th = Math.max(1, parseInt($('th').value||2,10));
  const tx0 = parseInt($('btx').value||0,10);
  const ty0 = parseInt($('bty').value||0,10);

  const {ISO_X, ISO_Y} = isoParams();
  const halfX = ISO_X * cam.zoom;
  const halfY = ISO_Y * cam.zoom;

  // We want the exact "big parallelogram + 3x2 subdivisions" look.
  // We'll draw the outline of the union of diamonds, then internal split lines.
  // Build corner points in screen space for the footprint boundary:
  // Using standard iso: tile corner points
  // We'll define the topmost tile center at (tx0,ty0) and compute boundary corners as:
  // A = top corner of tile (tx0,ty0)
  // B = rightmost corner after tw tiles along +x: top corner of tile (tx0+tw-1, ty0) shifted to right corner
  // C = bottom corner after tw along +x and th along +y
  // D = leftmost corner after th along +y
  // To make it stable and simple, we compute four boundary vertices directly:
  // V0: top vertex of tile (tx0,ty0)
  // V1: right vertex of tile (tx0+tw-1, ty0)
  // V2: bottom vertex of tile (tx0+tw-1, ty0+th-1)
  // V3: left vertex of tile (tx0, ty0+th-1)
  const pTop = worldToScreen((tx0+0.5)*TILE, (ty0+0.5)*TILE, cam);
  const pRight = worldToScreen((tx0+tw-1+0.5)*TILE, (ty0+0.5)*TILE, cam);
  const pBottom = worldToScreen((tx0+tw-1+0.5)*TILE, (ty0+th-1+0.5)*TILE, cam);
  const pLeft = worldToScreen((tx0+0.5)*TILE, (ty0+th-1+0.5)*TILE, cam);

  const V0 = {x:pTop.x, y:pTop.y - halfY};
  const V1 = {x:pRight.x + halfX, y:pRight.y};
  const V2 = {x:pBottom.x, y:pBottom.y + halfY};
  const V3 = {x:pLeft.x - halfX, y:pLeft.y};

  ctx.save();
  ctx.scale(dpr,dpr);
  const {baseX, baseY} = baseOffset();
  ctx.translate(view.panX + baseX, view.panY + baseY);
  ctx.scale(view.zoom, view.zoom);

  // outline
  ctx.lineWidth = 2;
  ctx.strokeStyle = 'rgba(79,227,160,0.95)';
  ctx.fillStyle = 'rgba(79,227,160,0.08)';
  ctx.beginPath();
  ctx.moveTo(V0.x, V0.y);
  ctx.lineTo(V1.x, V1.y);
  ctx.lineTo(V2.x, V2.y);
  ctx.lineTo(V3.x, V3.y);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // internal split lines (tw columns, th rows) in the "projected rect" sense:
  // We draw tw-1 lines parallel to V0->V3 (vertical-ish) and th-1 lines parallel to V0->V1 (horizontal-ish).
  ctx.lineWidth = 2;
  ctx.strokeStyle = 'rgba(79,227,160,0.75)';

  // column lines: split along +x direction (SE), i=1..tw-1
  for(let i=1;i<tw;i++){
    // line connects the i-th split on top edge (V0->V1) to corresponding split on bottom edge (V3->V2)
    const t = i/tw;
    const A = {x: V0.x + (V1.x - V0.x)*t, y: V0.y + (V1.y - V0.y)*t};
    const B = {x: V3.x + (V2.x - V3.x)*t, y: V3.y + (V2.y - V3.y)*t};
    ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();
  }
  // row lines: split along +y direction (SW), j=1..th-1
  for(let j=1;j<th;j++){
    const t = j/th;
    const A = {x: V0.x + (V3.x - V0.x)*t, y: V0.y + (V3.y - V0.y)*t};
    const B = {x: V1.x + (V2.x - V1.x)*t, y: V1.y + (V2.y - V1.y)*t};
    ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();
  }

  // axis / anchor marker
  if($('showAxis').checked){
    // show W (+x) and H (+y) directions like your diagram
    ctx.lineWidth = 3;
    // W arrow (SE)
    const origin = {x: V0.x, y: V0.y};
    const wEnd = {x: V0.x + (V1.x - V0.x), y: V0.y + (V1.y - V0.y)};
    const hEnd = {x: V0.x + (V3.x - V0.x), y: V0.y + (V3.y - V0.y)};
    ctx.strokeStyle = 'rgba(140,190,255,0.85)';
    drawArrow(origin, wEnd, 'W='+tw+' ↘(+x)', 10);
    drawArrow(origin, hEnd, 'H='+th+' ↙(+y)', 10);
  }

  ctx.restore();
}

function drawArrow(a,b,label,off){
  ctx.beginPath();
  ctx.moveTo(a.x,a.y);
  ctx.lineTo(b.x,b.y);
  ctx.stroke();
  const ang=Math.atan2(b.y-a.y,b.x-a.x);
  const hl=10;
  ctx.beginPath();
  ctx.moveTo(b.x,b.y);
  ctx.lineTo(b.x - hl*Math.cos(ang-0.5), b.y - hl*Math.sin(ang-0.5));
  ctx.lineTo(b.x - hl*Math.cos(ang+0.5), b.y - hl*Math.sin(ang+0.5));
  ctx.closePath();
  ctx.fillStyle='rgba(140,190,255,0.85)';
  ctx.fill();
  ctx.fillStyle='rgba(200,225,255,0.9)';
  ctx.font='12px system-ui, sans-serif';
  ctx.fillText(label, b.x + off*Math.cos(ang+Math.PI/2), b.y + off*Math.sin(ang+Math.PI/2));
}

function drawSprite(cam, view){
  const f=getCurrentFrame();
  if(!f || !textures[f.tex]?.img) return;

  const img=textures[f.tex].img;
  const sc=+($('spriteScale').value||0.14);

  const tx0 = parseInt($('btx').value||0,10);
  const ty0 = parseInt($('bty').value||0,10);
  const tw = Math.max(1, parseInt($('tw').value||3,10));
  const th = Math.max(1, parseInt($('th').value||2,10));
  const mode = $('anchorMode').value;

  // anchor point in tile coords
  const a = anchorTile(tx0, ty0, tw, th, mode);
  const p = worldToScreen((a.ax)*TILE, (a.ay)*TILE, cam);

  const {baseX, baseY} = baseOffset();

  // pivot in pixels of source size
  const px = (+$('pivotX').value||0.5) * f.source.w;
  const py = (+$('pivotY').value||0.5) * f.source.h;

  // draw position in screen space (before view transform)
  // replicate atlas_tp typical: draw = anchorScreen - (pivot - ssOffset) * scale
  // spriteSourceSize is the crop origin inside the original source.
  const dx = p.x - (px - f.ss.x) * sc;
  const dy = p.y - (py - f.ss.y) * sc;

  // draw cropped region from atlas
  const sx=f.rect.x, sy=f.rect.y, sw=f.rect.w, sh=f.rect.h;

  ctx.save();
  ctx.scale(dpr,dpr);
  ctx.translate(view.panX + baseX, view.panY + baseY);
  ctx.scale(view.zoom, view.zoom);

  ctx.imageSmoothingEnabled=true;
  ctx.drawImage(img, sx,sy,sw,sh, dx,dy, sw*sc, sh*sc);

  if($('showBounds').checked){
    ctx.strokeStyle='rgba(255,200,80,0.9)';
    ctx.lineWidth=2;
    ctx.strokeRect(dx,dy,sw*sc,sh*sc);
  }

  ctx.restore();

  // write debug
  const top = $('topInfo');
  const drawTxt = `atlas: ${$('prefix').value || '-'}  frame: ${f.name}  draw: (${dx.toFixed(1)},${dy.toFixed(1)})`;
  top.textContent = `canvas ${Math.round(cv.width/dpr)}x${Math.round(cv.height/dpr)}  |  ${drawTxt}`;
}

function updateOutput(){
  const x=+($('pivotX').value||0.5);
  const y=+($('pivotY').value||0.5);
  $('out').value = JSON.stringify({x:+x.toFixed(4), y:+y.toFixed(4)});
}

function tick(t){
  requestAnimationFrame(tick);
  if(!cv.width || !cv.height) return;
  const cam=getCam();
  const {TILE} = isoParams();
  const view={zoom:+($('viewZoom').value||1), panX, panY};
  clear();
  // Always draw grid/footprint even before atlas is loaded (so you can see the stage).
  drawGrid(cam, view);
  drawFootprintExact(cam, view);
  if(!atlasData || !frames.length){
    ctx.save(); ctx.scale(dpr,dpr);
    ctx.fillStyle='rgba(255,255,255,0.85)'; ctx.font='14px system-ui, sans-serif';
    ctx.fillText('No atlas loaded. Set Atlas JSON URL and press Load.', 18, 28);
    ctx.restore();
    return;
  }
  if(!textures.length){
    ctx.save(); ctx.scale(dpr,dpr);
    ctx.fillStyle='rgba(255,150,150,0.9)'; ctx.font='14px system-ui, sans-serif';
    ctx.fillText('Atlas JSON loaded, but texture image failed to load. Check meta.image path.', 18, 28);
    ctx.restore();
    return;
  }
  // animation
  if(playing){
    const fps=clamp(+($('fps').value||20),1,60);
    if(!lastT) lastT=t;
    const dt=t-lastT;
    const step = 1000/fps;
    if(dt>=step){
      lastT=t-(dt%step);
      // advance within prefix-filtered list if possible
      const prefix=$('prefix').value.trim();
      const list = frames.filter(f=>!prefix || f.name.startsWith(prefix));
      if(list.length){
        const curName = $('frameSel').value;
        const idx=list.findIndex(f=>f.name===curName);
        const next=list[(idx+1)%list.length];
        $('frameSel').value = next.name;
      }else{
        cur=(cur+1)%frames.length;
        $('frameSel').value = frames[cur].name;
      }
    }
  }else{
    lastT=0;
  }

  clear();
  drawGrid(cam, view);
  drawFootprintExact(cam, view);
  drawSprite(cam, view);
}

// ===== view controls
function resetView(){
  panX=0; panY=0;
  $('viewZoom').value=1;
}
function fitToFootprint(){
  // compute footprint bounds in screen space and adjust pan/zoom so it fits.
  const cam=getCam();
  const {TILE} = isoParams();
  const viewZoom=+($('viewZoom').value||1);
  const tw=Math.max(1, parseInt($('tw').value||3,10));
  const th=Math.max(1, parseInt($('th').value||2,10));
  const tx0=parseInt($('btx').value||0,10);
  const ty0=parseInt($('bty').value||0,10);

  const {ISO_X, ISO_Y} = isoParams();
  const halfX = ISO_X * cam.zoom;
  const halfY = ISO_Y * cam.zoom;

  const pTop = worldToScreen((tx0+0.5)*TILE, (ty0+0.5)*TILE, cam);
  const pRight = worldToScreen((tx0+tw-1+0.5)*TILE, (ty0+0.5)*TILE, cam);
  const pBottom = worldToScreen((tx0+tw-1+0.5)*TILE, (ty0+th-1+0.5)*TILE, cam);
  const pLeft = worldToScreen((tx0+0.5)*TILE, (ty0+th-1+0.5)*TILE, cam);

  const V0 = {x:pTop.x, y:pTop.y - halfY};
  const V1 = {x:pRight.x + halfX, y:pRight.y};
  const V2 = {x:pBottom.x, y:pBottom.y + halfY};
  const V3 = {x:pLeft.x - halfX, y:pLeft.y};

  const xs=[V0.x,V1.x,V2.x,V3.x], ys=[V0.y,V1.y,V2.y,V3.y];
  const minX=Math.min(...xs), maxX=Math.max(...xs);
  const minY=Math.min(...ys), maxY=Math.max(...ys);
  const bw=maxX-minX, bh=maxY-minY;

  const w=cv.width/dpr, h=cv.height/dpr;
  const pad=60;
  const zx=(w-pad)/Math.max(1,bw);
  const zy=(h-pad)/Math.max(1,bh);
  const z=clamp(Math.min(zx,zy), 0.2, 4);
  $('viewZoom').value = +z.toFixed(2);

  // center footprint in view
  const cx=(minX+maxX)/2, cy=(minY+maxY)/2;
  // we want cx,cy to land at (0,0) after pan, because baseOffset already centers
  panX = -cx;
  panY = -cy;
}

// mouse interactions
cv.addEventListener('mousedown',(e)=>{
  isPanning=true;
  panStart={x:e.clientX, y:e.clientY, px:panX, py:panY};
});
window.addEventListener('mouseup',()=>{ isPanning=false; panStart=null; });
window.addEventListener('mousemove',(e)=>{
  if(!isPanning||!panStart) return;
  const dx=e.clientX-panStart.x;
  const dy=e.clientY-panStart.y;
  panX = panStart.px + dx;
  panY = panStart.py + dy;
});
cv.addEventListener('wheel',(e)=>{
  e.preventDefault();
  const z=+($('viewZoom').value||1);
  const delta = Math.sign(e.deltaY);
  const next = clamp(z * (delta>0 ? 0.9 : 1.1), 0.1, 10);
  $('viewZoom').value = +next.toFixed(2);
},{passive:false});
cv.addEventListener('dblclick', (e)=>{ fitToFootprint(); });

// ===== apply & download
function applyToPrefix(){
  const prefix=$('prefix').value.trim();
  if(!prefix){ setStatus('ERR: prefix empty','err'); return; }
  const x=+($('pivotX').value||0.5);
  const y=+($('pivotY').value||0.5);
  let n=0;
  for(const f of frames){
    if(f.name.startsWith(prefix)){
      f.anchor={x,y};
      if(f.rawRef) f.rawRef.anchor={x,y};
      n++;
    }
  }
  setStatus(`Applied anchor {x:${x.toFixed(4)}, y:${y.toFixed(4)}} to ${n} frame(s) with prefix "${prefix}".`,'ok');
}

function downloadPatched(){
  if(!atlasData){ setStatus('ERR: no atlas loaded','err'); return; }
  // If original JSON used textures[], we patched rawRef anchors only; safe to stringify atlasData.
  const blob = new Blob([JSON.stringify(atlasData, null, 2)], {type:'application/json'});
  const a=document.createElement('a');
  a.href=URL.createObjectURL(blob);
  const name = ( $('prefix').value.trim() || 'atlas' ) + '_patched.json';
  a.download=name;
  a.click();
  URL.revokeObjectURL(a.href);
  setStatus('Downloaded: ' + name,'ok');
}

// ===== wiring
$('btnLoad').addEventListener('click', loadAtlas);
$('btnReload').addEventListener('click', loadAtlas);

$('chipIdle').addEventListener('click', ()=>{
  $('atlasUrl').value='asset/sprite/const/normal/barrack/barrack_idle.json';
  $('prefix').value='barrack_idle';
});
$('chipConst').addEventListener('click', ()=>{
  $('atlasUrl').value='asset/sprite/const/const_anim/barrack/barrack_const.json';
  $('prefix').value='barrack_con_complete';
});
$('chipDist').addEventListener('click', ()=>{
  $('atlasUrl').value='asset/sprite/const/distruct/barrack/barrack_distruct.json';
  $('prefix').value='barrack_distruction';
});

$('prefix').addEventListener('change', ()=>{ rebuildFrameSelect(); syncPivotFromFrame(); });
$('frameSel').addEventListener('change', ()=>{ playing=false; lastT=0; syncPivotFromFrame(); });
$('btnPlay').addEventListener('click', ()=>{ playing=true; });
$('btnPause').addEventListener('click', ()=>{ playing=false; });
$('btnStep').addEventListener('click', ()=>{
  playing=false;
  const prefix=$('prefix').value.trim();
  const list = frames.filter(f=>!prefix || f.name.startsWith(prefix));
  if(list.length){
    const curName=$('frameSel').value;
    const idx=list.findIndex(f=>f.name===curName);
    const next=list[(idx+1)%list.length];
    $('frameSel').value=next.name;
  }else if(frames.length){
    cur=(cur+1)%frames.length;
    $('frameSel').value=frames[cur].name;
  }
});

function nudgePivot(dx,dy){
  const x=clamp(+( $('pivotX').value ) + dx, 0, 1);
  const y=clamp(+( $('pivotY').value ) + dy, 0, 1);
  $('pivotX').value=x; $('pivotY').value=y;
  updateOutput();
}
$('btnXMinus').addEventListener('click', ()=>nudgePivot(-0.001,0));
$('btnXPlus').addEventListener('click', ()=>nudgePivot(0.001,0));
$('btnYMinus').addEventListener('click', ()=>nudgePivot(0,-0.001));
$('btnYPlus').addEventListener('click', ()=>nudgePivot(0,0.001));
$('pivotX').addEventListener('input', updateOutput);
$('pivotY').addEventListener('input', updateOutput);

$('btnApplyPrefix').addEventListener('click', applyToPrefix);
$('btnDownload').addEventListener('click', downloadPatched);

$('btnResetView').addEventListener('click', resetView);
$('btnFit').addEventListener('click', fitToFootprint);

// re-render on input changes
for(const id of ['tile','camZoom','camX','camY','btx','bty','tw','th','anchorMode','baseYRatio','viewZoom','gridSpan','showGrid','showFoot','showAxis','showBounds','spriteScale']){
  $(id).addEventListener('input', ()=>{});
  $(id).addEventListener('change', ()=>{});
}

requestAnimationFrame(tick);
updateOutput();
</script>
</body>
</html>