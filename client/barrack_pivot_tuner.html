<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Barrack Pivot Tuner v3 (game-matched)</title>
<style>
  :root {
    --bg0:#0b0f16; --bg1:#111a2b; --panel:#0d1421; --line:rgba(255,255,255,.08);
    --text:rgba(255,255,255,.92); --muted:rgba(255,255,255,.62);
    --acc:#79a7ff; --warn:#ffce6a; --bad:#ff6a7a; --ok:#6cffb0;
  }
  html,body { height:100%; margin:0; background:linear-gradient(160deg,var(--bg0),var(--bg1)); color:var(--text); font-family:system-ui,-apple-system,Segoe UI,Roboto,Apple SD Gothic Neo,Noto Sans KR,sans-serif; }
  #app { height:100vh; display:flex; }
  aside {
    width:360px; min-width:320px; max-width:420px;
    border-right:1px solid var(--line);
    background:linear-gradient(180deg,rgba(10,16,28,.9),rgba(10,16,28,.55));
    padding:14px 12px; box-sizing:border-box; overflow:auto;
  }
  main#right { flex:1; position:relative; overflow:hidden; }
  #cv {
    position:absolute; inset:0;
    display:block;
    width:100%; height:100%;
    z-index:1;
  }
  #hud {
    position:absolute; left:12px; top:10px; z-index:3;
    display:flex; gap:8px; align-items:center;
    padding:6px 10px; border:1px solid var(--line);
    border-radius:12px;
    background:rgba(0,0,0,.28); backdrop-filter: blur(6px);
    font-size:12px; color:var(--muted);
    user-select:none;
  }
  .badge { padding:2px 8px; border-radius:999px; border:1px solid var(--line); }
  .ok { color:var(--ok); }
  .bad { color:var(--bad); }
  h1 { font-size:15px; margin:0 0 10px; letter-spacing:.2px; }
  .hint { font-size:12px; color:var(--muted); line-height:1.35; margin:0 0 10px; }
  .card {
    border:1px solid var(--line);
    border-radius:14px;
    padding:10px;
    margin:10px 0;
    background:rgba(255,255,255,.03);
  }
  .row { display:flex; gap:8px; align-items:center; }
  label { font-size:12px; color:var(--muted); display:block; margin:6px 0 6px; }
  input[type="text"], input[type="number"], select, textarea {
    width:100%;
    box-sizing:border-box;
    background:rgba(0,0,0,.25);
    color:var(--text);
    border:1px solid var(--line);
    border-radius:10px;
    padding:8px 10px;
    outline:none;
  }
  input[type="range"] { width:100%; }
  textarea { min-height:110px; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Noto Sans Mono", monospace; font-size:12px; }
  button {
    border:1px solid var(--line);
    background:rgba(255,255,255,.06);
    color:var(--text);
    border-radius:10px;
    padding:8px 10px;
    cursor:pointer;
  }
  button:hover { background:rgba(255,255,255,.10); }
  button.primary { border-color:rgba(121,167,255,.55); background:rgba(121,167,255,.14); }
  button.danger { border-color:rgba(255,106,122,.55); background:rgba(255,106,122,.10); }
  .grid2 { display:grid; grid-template-columns:1fr 1fr; gap:8px; }
  .grid3 { display:grid; grid-template-columns:1fr 1fr 1fr; gap:8px; }
  .tiny { font-size:11px; color:var(--muted); }
  .pillrow { display:flex; gap:6px; flex-wrap:wrap; }
  .pill {
    font-size:11px; padding:4px 8px; border-radius:999px;
    border:1px solid var(--line); color:var(--muted);
    background:rgba(0,0,0,.22);
  }
  .status {
    font-size:12px; padding:8px 10px; border-radius:12px;
    border:1px solid var(--line); background:rgba(0,0,0,.22);
    white-space:pre-wrap;
  }
  .status.ok { border-color:rgba(108,255,176,.35); }
  .status.bad { border-color:rgba(255,106,122,.45); }
  .warnbox {
    font-size:12px; color:var(--warn); line-height:1.3;
    padding:8px 10px; border-radius:12px;
    border:1px solid rgba(255,206,106,.25);
    background:rgba(255,206,106,.06);
  }
</style>
</head>
<body>
<div id="app">
  <aside>
    <h1>Pivot Tuner v3 ğŸ§° (ê²Œì„ ì¢Œí‘œ 1:1)</h1>
    <p class="hint">
      ëª©ì : <b>game.js</b>ì˜ ì¢Œí‘œ/ì¹´ë©”ë¼/ë² ì´ìŠ¤ì˜¤í”„ì…‹ ê³„ì‚°ê³¼ ë™ì¼í•˜ê²Œ ìº”ë²„ìŠ¤ì— ê±´ë¬¼ ìŠ¤í”„ë¼ì´íŠ¸ë¥¼ ì°ì–´ì„œ,
      ì—¬ê¸°ì„œ ì¡ì€ <b>anchor(x,y)</b>ê°€ ê²Œì„ì—ì„œ ê·¸ëŒ€ë¡œ ë§ë„ë¡ í•˜ëŠ” íŠœë„ˆ.
    </p>

    <div class="warnbox">
      âš ï¸ ë„¤ ìŠ¤ìƒ· Atlas URLì´ <b>/consts/</b>ë¡œ ë¼ìˆë”ë¼. í´ë”ëŠ” <b>/const/</b>ê°€ ë§ì•„.
      (404ë©´ JSON ëŒ€ì‹  HTMLì´ ì™€ì„œ â€œì•„ë¬´ê²ƒë„ ì•ˆ ë³´ì„â€ ë°œìƒ ê°€ëŠ¥)
    </div>

    <div class="card">
      <label>Atlas JSON URL</label>
      <input id="jsonUrl" type="text" value="/asset/sprite/const/distruct/barrack/barrack_distruct.json" />
      <div class="pillrow" style="margin-top:8px;">
        <button id="btnIdle">barrack idle</button>
        <button id="btnConst">barrack const</button>
        <button id="btnDist">barrack dist</button>
      </div>
      <div class="row" style="margin-top:8px;">
        <button id="btnLoad" class="primary" style="flex:1;">Load</button>
        <button id="btnReload" style="width:120px;">Reload</button>
      </div>
      <div style="margin-top:8px;" id="loadStatus" class="status">Ready.</div>
    </div>

    <div class="card">
      <div class="grid2">
        <div>
          <label>Set (prefix)</label>
          <select id="prefixSel"></select>
        </div>
        <div>
          <label>Frame</label>
          <select id="frameSel"></select>
        </div>
      </div>

      <div class="grid3" style="margin-top:10px;">
        <div>
          <label>FPS</label>
          <input id="fps" type="number" min="1" max="60" step="1" value="20" />
        </div>
        <div>
          <label>Scale</label>
          <input id="scale" type="number" min="0.01" max="2" step="0.01" value="0.14" />
        </div>
        <div>
          <label>Play</label>
          <div class="row">
            <button id="btnPlay" style="flex:1;">â–¶</button>
            <button id="btnStop" style="flex:1;">â– </button>
          </div>
        </div>
      </div>

      <label style="margin-top:10px;">Pivot X (normalized 0..1)</label>
      <input id="px" type="range" min="0" max="1" step="0.0001" value="0.50" />
      <div class="row">
        <button id="pxM" style="flex:1;">X-</button>
        <button id="pxP" style="flex:1;">X+</button>
        <div class="tiny" id="pxVal" style="width:90px; text-align:right;">0.5000</div>
      </div>

      <label style="margin-top:10px;">Pivot Y (normalized 0..1)</label>
      <input id="py" type="range" min="0" max="1" step="0.0001" value="0.50" />
      <div class="row">
        <button id="pyM" style="flex:1;">Y-</button>
        <button id="pyP" style="flex:1;">Y+</button>
        <div class="tiny" id="pyVal" style="width:90px; text-align:right;">0.5000</div>
      </div>

      <div class="grid2" style="margin-top:10px;">
        <button id="btnApplyPrefix" class="primary">Apply pivot to prefix</button>
        <button id="btnDownload">Download patched JSON</button>
      </div>

      <label style="margin-top:10px;">Copy/paste (JSON anchor)</label>
      <textarea id="out" readonly></textarea>
      <div class="tiny" id="debugLine"></div>
    </div>

    <div class="card">
      <label>ê²Œì„ ì¢Œí‘œ ëª¨ë“œ</label>
      <div class="grid3">
        <div>
          <label>TILE</label>
          <input id="tile" type="number" value="128" />
        </div>
        <div>
          <label>ISO_X</label>
          <input id="isoX" type="number" value="64" />
        </div>
        <div>
          <label>ISO_Y</label>
          <input id="isoY" type="number" value="32" />
        </div>
      </div>

      <div class="grid3" style="margin-top:10px;">
        <div>
          <label>Cam tileX</label>
          <input id="camTX" type="number" value="0" />
        </div>
        <div>
          <label>Cam tileY</label>
          <input id="camTY" type="number" value="0" />
        </div>
        <div>
          <label>Cam zoom</label>
          <input id="camZoom" type="number" min="0.1" max="4" step="0.05" value="1" />
        </div>
      </div>

      <div class="grid2" style="margin-top:10px;">
        <div>
          <label>Footprint W (tw)</label>
          <input id="fpW" type="number" min="1" max="8" value="3" />
        </div>
        <div>
          <label>Footprint H (th)</label>
          <input id="fpH" type="number" min="1" max="8" value="2" />
        </div>
      </div>

      <div class="grid2" style="margin-top:6px;">
        <div>
          <label>Footprint Y ë°©í–¥</label>
          <select id="fpYDir">
            <option value="ne" selected>NE (ty ê°ì†Œ, â†—)</option>
            <option value="sw">SW (ty ì¦ê°€, â†™)</option>
          </select>
        </div>
        <div>
          <label style="opacity:.8">ì„¤ëª…</label>
          <div class="small">ë„¤ ê²Œì„ì²˜ëŸ¼ "3Ã—2ê°€ ë™ë‚¨ìª½ìœ¼ë¡œ ê¸¸ê²Œ" ë³´ì´ê²Œ í•˜ë ¤ë©´ NE(ty ê°ì†Œ)ë¥¼ ì“°ë©´ ë¨.</div>
        </div>
      </div>

      <div class="grid2" style="margin-top:10px;">
        <div>
          <label>Building tx</label>
          <input id="bTX" type="number" value="0" />
        </div>
        <div>
          <label>Building ty</label>
          <input id="bTY" type="number" value="0" />
        </div>
      </div>

      <div class="grid2" style="margin-top:10px;">
        <div>
          <label>Anchor mode</label>
          <select id="anchorMode">
            <option value="center" selected>center (footprint center)</option>
            <option value="south">south (footprint south edge)</option>
          </select>
        </div>
        <div>
          <label>BaseOffset Y ratio (game.js=0.22)</label>
          <input id="baseYRatio" type="number" min="0" max="1" step="0.01" value="0.22" />
        </div>
      </div>

      <div class="grid2" style="margin-top:10px;">
        <div class="row">
          <input id="showGrid" type="checkbox" checked />
          <label for="showGrid" style="margin:0;">íƒ€ì¼ ê·¸ë¦¬ë“œ í‘œì‹œ</label>
        </div>
        <div class="row">
          <input id="showFoot" type="checkbox" checked />
          <label for="showFoot" style="margin:0;">í’‹í”„ë¦°íŠ¸ íƒ€ì¼(ë‹¤ì´ì•„) í‘œì‹œ</label>
        </div>
      </div>

      <div class="grid2" style="margin-top:10px;">
        <div class="row">
          <input id="showAxis" type="checkbox" checked />
          <label for="showAxis" style="margin:0;">í’‹í”„ë¦°íŠ¸ ì¶•(â†˜/â†™) í‘œì‹œ</label>
        </div>
        <div class="row">
          <input id="showMini" type="checkbox" checked />
          <label for="showMini" style="margin:0;">íƒ‘ë‹¤ìš´(ì§ì‚¬ê°í˜•) ë¯¸ë‹ˆë·°</label>
        </div>
      </div>

      <div id="miniWrap" style="margin-top:10px;">
        <div class="small muted" style="margin-bottom:6px;">
          ì•„ì´ì†Œ í™”ë©´ì—ì„  â€œì§ì‚¬ê°í˜• í’‹í”„ë¦°íŠ¸â€ê°€ í‰í–‰ì‚¬ë³€í˜•ì²˜ëŸ¼ ë³´ì´ëŠ” ê²Œ ì •ìƒ.
          í—·ê°ˆë¦¬ë©´ ì•„ë˜ ë¯¸ë‹ˆë·°ì—ì„œ 3Ã—2 ê°™ì€ ì§ì‚¬ê°í˜•ì„ ê°™ì´ ë´.
        </div>
        <canvas id="miniCv" width="260" height="180" style="width:100%;height:auto;border:1px solid rgba(255,255,255,.08);border-radius:10px;background:rgba(0,0,0,.25)"></canvas>
      </div>


      <div class="grid2" style="margin-top:10px;">
        <div class="row">
          <input id="showAnchor" type="checkbox" checked />
          <label for="showAnchor" style="margin:0;">ì•µì»¤(ì°ëŠ”ì ) í‘œì‹œ</label>
        </div>
        <div class="row">
          <input id="// draw mode: match in-game barracks renderer (bottom-center of frame bbox pinned to screenAnchor)
const modeIngame = document.getElementById('modeIngame')?.checked ?? true;

let drawX = screenAnchor.x;
let drawY = screenAnchor.y;

if (modeIngame) {
  const fr = atlas.frames.get(curFrame);
  if (fr) {
    const f = fr.frame;                 // trimmed frame rect in texture
    const sss = fr.spriteSourceSize;    // trimmed rect position in original source
    const src = fr.sourceSize;          // original untrimmed source size

    const px = src.w * pivot.x;
    const py = src.h * pivot.y;

    const x0 = (-px + sss.x) * scale;
    const y0 = (-py + sss.y) * scale;
    const x1 = x0 + f.w * scale;
    const y1 = y0 + f.h * scale;

    // bottom-center point of the rendered frame bbox, relative to pivot
    const bcX = (x0 + x1) * 0.5;
    const bcY = y1;

    // choose pivot position so that bbox bottom-center sits on screenAnchor
    drawX = screenAnchor.x - bcX;
    drawY = screenAnchor.y - bcY;
  }
}

window.PO.atlasTP.drawFrame(ctx, atlas, curFrame, drawX, drawY, { scale, pivot });" type="checkbox" />
          <label for="showBounds" style="margin:0;">í”„ë ˆì„ bbox í‘œì‹œ</label>
        </div>
      </div>
    </div>

  </aside>

  <main id="right">
    <canvas id="cv"></canvas>
    <div id="hud">
      <span class="badge" id="hudCanvas">canvas: ?</span>
      <span class="badge" id="hudAtlas">atlas: -</span>
      <span class="badge" id="hudDraw" class="ok">draw: -</span>
    </div>
  </main>
</div>

<script>
/* ==== atlas_tp.js (Project-Outrage) inline ==== */
window.PO = window.PO || {};
/* atlas_tp.js (TexturePacker) v6 + v22 back-compat
   - Supports TP Multi (textures[] array) and TP Hash (frames:{}), plus frames[] array.
   - Produces atlas.frames (Map) and atlas.framesByName (plain object) for compatibility.
   - Provides drawFrame() that respects trimming and optional rotated frames.
*/
(() => {
  const PO = (window.PO = window.PO || {});
  PO.atlasTP = PO.atlasTP || {};

  const VERSION = 6;

  function looksLikeHTML(s) {
    if (!s) return false;
    const head = String(s).trimStart().slice(0, 80).toLowerCase();
    return head.startsWith('<!doctype') || head.startsWith('<html') || head.includes('<head') || head.includes('<body');
  }

  function baseDirFromUrl(url) {
    const q = url.split('?')[0].split('#')[0];
    const i = q.lastIndexOf('/');
    if (i <= 0) return '';
    return q.slice(0, i);
  }

  function joinUrl(base, rel) {
    if (!base) return rel;
    if (!rel) return base;
    const b = base.endsWith('/') ? base.slice(0, -1) : base;
    if (rel.startsWith('/')) return b + rel;
    return b + '/' + rel;
  }

  function isPlainObject(x) {
    return x && typeof x === 'object' && !Array.isArray(x);
  }

  function toRect(r) {
    if (!r) return { x: 0, y: 0, w: 0, h: 0 };
    // TP usually uses {x,y,w,h}
    const x = Number(r.x || 0);
    const y = Number(r.y || 0);
    const w = Number(r.w ?? r.width ?? 0);
    const h = Number(r.h ?? r.height ?? 0);
    return { x, y, w, h };
  }

  function toSize(s) {
    if (!s) return { w: 0, h: 0 };
    const w = Number(s.w ?? s.width ?? 0);
    const h = Number(s.h ?? s.height ?? 0);
    return { w, h };
  }

  function toSpriteSourceSize(ss, fallbackW, fallbackH) {
    if (!ss) return { x: 0, y: 0, w: fallbackW, h: fallbackH };
    const x = Number(ss.x || 0);
    const y = Number(ss.y || 0);
    const w = Number(ss.w ?? ss.width ?? fallbackW);
    const h = Number(ss.h ?? ss.height ?? fallbackH);
    return { x, y, w, h };
  }

  function normalizeFrameCommon(filename, fr, texIndex) {
    const frame = toRect(fr.frame || fr);
    const rotated = !!fr.rotated;
    const trimmed = !!fr.trimmed;
    const sourceSize = toSize(fr.sourceSize);
    const spriteSourceSize = toSpriteSourceSize(fr.spriteSourceSize, frame.w, frame.h);
    const pivot = fr.pivot || fr.anchor || null; // TP uses pivot, some tools use anchor
    return {
      name: filename,
      texIndex,
      frame,
      rotated,
      trimmed,
      sourceSize,
      spriteSourceSize,
      pivot, // {x,y} normalized (0..1) in sourceSize space
    };
  }

  function parseTP(data) {
    // Returns { textures: [{image, frames: [frameObj]}] }
    if (!data) throw new Error('Invalid atlas JSON (empty).');

    // Multi pack: { textures:[{image, frames:[...]}] }
    if (Array.isArray(data.textures)) {
      const textures = data.textures.map((t) => ({
        image: t.image,
        frames: Array.isArray(t.frames) ? t.frames : [],
      }));
      return { textures };
    }

    // Hash format: { frames: {name:{frame...}, ...}, meta:{image:"x.png"} }
    if (isPlainObject(data.frames)) {
      const image = data.meta && data.meta.image ? data.meta.image : (data.image || null);
      if (!image) throw new Error('TP hash atlas missing meta.image');
      const framesArr = Object.entries(data.frames).map(([name, fr]) => {
        const obj = Object.assign({ filename: name }, fr);
        return obj;
      });
      return { textures: [{ image, frames: framesArr }] };
    }

    // Array frames format: { frames:[{filename,...}], meta:{image:"x.png"} }
    if (Array.isArray(data.frames)) {
      const image = data.meta && data.meta.image ? data.meta.image : (data.image || null);
      if (!image) throw new Error('TP frames[] atlas missing meta.image');
      return { textures: [{ image, frames: data.frames }] };
    }

    throw new Error('Unsupported atlas JSON shape (need textures[] or frames).');
  }

  function loadImage(src) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      // Safe default for canvas use; same-origin still works.
      img.crossOrigin = 'anonymous';
      img.decoding = 'async';
      img.onload = () => resolve(img);
      img.onerror = () => reject(new Error('Image load failed: ' + src));
      img.src = src;
    });
  }

  async function loadTPAtlasMulti(jsonUrl, baseDirOpt = null) {
    const resp = await fetch(jsonUrl, { cache: 'no-store' });
    const text = await resp.text();
    if (!resp.ok) throw new Error(`Atlas JSON fetch failed: ${jsonUrl} (HTTP ${resp.status})`);
    if (looksLikeHTML(text)) throw new Error(`Atlas URL returned HTML (likely SPA fallback): ${jsonUrl}`);
    const trimmed = text.trimStart();
    if (!trimmed || (trimmed[0] !== '{' && trimmed[0] !== '[')) throw new Error(`Atlas JSON is not JSON: ${jsonUrl}`);
    let raw;
    try { raw = JSON.parse(text); } catch (e) { throw new Error(`Invalid JSON at ${jsonUrl}: ${e.message}`); }

    const parsed = parseTP(raw);
    const baseDir = baseDirOpt || baseDirFromUrl(jsonUrl);

    // Load images
    const textures = [];
    for (let i = 0; i < parsed.textures.length; i++) {
      const t = parsed.textures[i];
      if (!t.image) throw new Error(`TP atlas missing textures[${i}].image`);
      const src = joinUrl(baseDir, t.image);
      const img = await loadImage(src);
      textures.push({ image: t.image, src, img });
    }

    // Frames map
    const frames = new Map();
    const framesByName = Object.create(null);

    parsed.textures.forEach((t, texIndex) => {
      const arr = Array.isArray(t.frames) ? t.frames : [];
      for (const fr of arr) {
        const filename = fr.filename || fr.name;
        if (!filename) continue;
        const frameObj = normalizeFrameCommon(filename, fr, texIndex);
        frames.set(filename, frameObj);
        framesByName[filename] = frameObj;
      }
    });

    const atlas = {
      version: VERSION,
      jsonUrl,
      baseDir,
      textures,          // [{image, src, img}]
      frames,            // Map(name -> frameObj)
      framesByName,      // plain object alias
      _rotCache: new Map()
    };

    return atlas;
  }

  // Alias (single-sheet is still supported by loadTPAtlasMulti)
  async function loadTPAtlas(jsonUrl, baseDirOpt = null) {
    return loadTPAtlasMulti(jsonUrl, baseDirOpt);
  }

  function trailingNumber(name) {
    // Pick last run of digits before extension
    const m = String(name).match(/(\d+)(?:\.[^./\\]+)?$/);
    return m ? parseInt(m[1], 10) : NaN;
  }

  function listFramesByPrefix(atlas, prefix, opts = {}) {
    const { sort = true } = opts;
    if (!atlas || !atlas.frames) return [];
    const out = [];
    for (const k of atlas.frames.keys()) {
      if (k.startsWith(prefix)) out.push(k);
    }
    if (sort) {
      out.sort((a, b) => {
        const na = trailingNumber(a), nb = trailingNumber(b);
        if (!Number.isNaN(na) && !Number.isNaN(nb)) return na - nb;
        return a.localeCompare(b);
      });
    }
    return out;
  }

  function applyPivotByPrefix(atlas, prefix, pivot) {
    if (!atlas || !atlas.frames) return 0;
    let n = 0;
    for (const [k, fr] of atlas.frames.entries()) {
      if (!k.startsWith(prefix)) continue;
      fr.pivot = { x: pivot.x, y: pivot.y };
      atlas.framesByName[k] = fr;
      n++;
    }
    return n;
  }

  function getFrameBounds(atlas, frameName) {
    const fr = atlas && atlas.frames ? atlas.frames.get(frameName) : null;
    if (!fr) return null;
    const sw = fr.sourceSize.w || fr.frame.w;
    const sh = fr.sourceSize.h || fr.frame.h;
    const px = fr.pivot ? fr.pivot.x : 0.5;
    const py = fr.pivot ? fr.pivot.y : 0.5;
    return {
      sourceW: sw,
      sourceH: sh,
      pivotX: px,
      pivotY: py,
      trimX: fr.spriteSourceSize.x,
      trimY: fr.spriteSourceSize.y,
      trimW: fr.spriteSourceSize.w,
      trimH: fr.spriteSourceSize.h,
    };
  }

  function getRotatedCanvas(atlas, fr) {
    const key = `${fr.texIndex}:${fr.name}`;
    if (atlas._rotCache.has(key)) return atlas._rotCache.get(key);
    const tex = atlas.textures[fr.texIndex];
    const img = tex.img;
    const { x: sx, y: sy, w: sw, h: sh } = fr.frame;
    // If rotated, TP packed the sprite rotated 90deg clockwise. Undo by rotating -90.
    const c = document.createElement('canvas');
    c.width = sh;
    c.height = sw;
    const cctx = c.getContext('2d');
    cctx.save();
    cctx.translate(0, c.height);
    cctx.rotate(-Math.PI / 2);
    cctx.drawImage(img, sx, sy, sw, sh, 0, 0, sw, sh);
    cctx.restore();
    atlas._rotCache.set(key, c);
    return c;
  }

  // Draw frame so that (x,y) is the pivot point in world space.
  function drawFrame(ctx, atlas, frameName, x, y, opts = {}) {
    if (!ctx || !atlas || !atlas.frames) return false;
    const fr = atlas.frames.get(frameName);
    if (!fr) return false;

    const scale = Number(opts.scale ?? 1);
    const alpha = Number(opts.alpha ?? 1);

    const tex = atlas.textures[fr.texIndex];
    const img = tex.img;

    // Original (untrimmed) size
    const origW = fr.sourceSize.w || (fr.rotated ? fr.frame.h : fr.frame.w);
    const origH = fr.sourceSize.h || (fr.rotated ? fr.frame.w : fr.frame.h);

    const pivot = opts.pivot || fr.pivot || { x: 0.5, y: 0.5 };
    const px = pivot.x ?? 0.5;
    const py = pivot.y ?? 0.5;

    const trimX = fr.spriteSourceSize.x || 0;
    const trimY = fr.spriteSourceSize.y || 0;

    // Dest top-left for the trimmed rectangle
    const dx = x - px * origW * scale + trimX * scale;
    const dy = y - py * origH * scale + trimY * scale;

    ctx.save();
    ctx.globalAlpha = ctx.globalAlpha * alpha;

    if (!fr.rotated) {
      const { x: sx, y: sy, w: sw, h: sh } = fr.frame;
      ctx.drawImage(img, sx, sy, sw, sh, dx, dy, sw * scale, sh * scale);
    } else {
      // Use cached un-rotated trimmed canvas
      const c = getRotatedCanvas(atlas, fr);
      ctx.drawImage(c, 0, 0, c.width, c.height, dx, dy, c.width * scale, c.height * scale);
    }

    ctx.restore();
    return true;
  }

  // Export API
  PO.atlasTP.version = VERSION;
  PO.atlasTP.loadTPAtlasMulti = loadTPAtlasMulti;
  PO.atlasTP.loadTPAtlas = loadTPAtlas;
  PO.atlasTP.drawFrame = drawFrame;
  PO.atlasTP.getFrameBounds = getFrameBounds;
  PO.atlasTP.listFramesByPrefix = listFramesByPrefix;
  PO.atlasTP.applyPivotByPrefix = applyPivotByPrefix;

  // Back-compat aliases (older patches expect loadAtlasTP*)
  PO.atlasTP.loadAtlasTP = loadTPAtlas;
  PO.atlasTP.loadAtlasTPMulti = loadTPAtlasMulti;

  console.log(`[atlas_tp:v${VERSION}] ready`);
})();

</script>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  const cv = $('cv');
  const ctx = cv.getContext('2d', { alpha:true });

  let dpr = Math.max(1, window.devicePixelRatio || 1);
  let atlas = null;
  let framesByPrefix = new Map(); // prefix -> [frameNames]
  let curPrefix = '';
  let curFrame = '';
  let playing = false;
  let tPrev = performance.now();
  let acc = 0;
  let frameIdx = 0;
  let lastDrawAt = 0;
  let lastErr = '';

  function setStatus(msg, kind='ok') {
    const el = $('loadStatus');
    el.textContent = msg;
    el.classList.toggle('bad', kind==='bad');
    el.classList.toggle('ok', kind==='ok');
  }

  function setHud() {
    const w = Math.round(cv.width / dpr);
    const h = Math.round(cv.height / dpr);
    $('hudCanvas').textContent = `canvas: ${w}x${h} (dpr=${dpr.toFixed(2)})`;
    $('hudAtlas').textContent = atlas ? `atlas: ${curPrefix || '-'}` : 'atlas: -';
    $('hudDraw').textContent = `draw: ${new Date(lastDrawAt).toLocaleTimeString()}`;
  }

  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

  function parseNum(id, def=0) {
    const v = parseFloat($(id).value);
    return Number.isFinite(v) ? v : def;
  }

  function resizeCanvas() {
    const r = $('right').getBoundingClientRect();
    const cssW = Math.max(2, Math.floor(r.width));
    const cssH = Math.max(2, Math.floor(r.height));
    dpr = Math.max(1, window.devicePixelRatio || 1);

    const wantW = Math.floor(cssW * dpr);
    const wantH = Math.floor(cssH * dpr);

    if (cv.width !== wantW || cv.height !== wantH) {
      cv.width = wantW;
      cv.height = wantH;
      cv.style.width = cssW + 'px';
      cv.style.height = cssH + 'px';
    }
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    setHud();
  }

  function bootResizeObservers() {
    // 1) flex ë ˆì´ì•„ì›ƒ/DevTools dock ë³€í™” ëŒ€ì‘
    const ro = new ResizeObserver(() => {
      resizeCanvas();
      render();
    });
    ro.observe($('right'));

    // 2) ë¸Œë¼ìš°ì € ë¦¬ì‚¬ì´ì¦ˆ ëŒ€ì‘
    window.addEventListener('resize', () => {
      resizeCanvas();
      render();
    }, { passive:true });

    // 3) ì²« í˜ì¸íŠ¸ ì´í›„ì— í•œ ë²ˆ ë” (ì´ˆê¸° 300x150 ë°©ì§€)
    requestAnimationFrame(() => {
      resizeCanvas();
      render();
    });
    setTimeout(() => {
      resizeCanvas();
      render();
    }, 60);
  }

  function makePrefixesFromAtlas(atlasObj) {
    const map = new Map();
    const names = Array.from(atlasObj.frames.keys());
    for (const name of names) {
      // prefix heuristic: up to last '_' or last digit run
      let p = name;
      const under = name.lastIndexOf('_');
      if (under !== -1) p = name.slice(0, under);
      // Special: barrack_idle1.png -> barrack_idle
      p = p.replace(/\d+\.png$/i, '.png');
      p = p.replace(/\.png$/i, '');
      if (!map.has(p)) map.set(p, []);
      map.get(p).push(name);
    }
    for (const [k, arr] of map.entries()) {
      arr.sort((a,b) => a.localeCompare(b, undefined, {numeric:true}));
    }
    return map;
  }

  function setPrefix(prefix) {
    curPrefix = prefix;
    const list = framesByPrefix.get(prefix) || [];
    const sel = $('frameSel');
    sel.innerHTML = '';
    for (const f of list) {
      const opt = document.createElement('option');
      opt.value = f; opt.textContent = f;
      sel.appendChild(opt);
    }
    curFrame = list[0] || '';
    frameIdx = 0;
    if (curFrame) sel.value = curFrame;
    $('prefixSel').value = prefix;
    render();
  }

  function setFrame(name) {
    curFrame = name;
    const list = framesByPrefix.get(curPrefix) || [];
    frameIdx = Math.max(0, list.indexOf(name));
    $('frameSel').value = name;
    render();
  }

  function refreshSelectors() {
    const pSel = $('prefixSel');
    pSel.innerHTML = '';
    const prefixes = Array.from(framesByPrefix.keys()).sort((a,b)=>a.localeCompare(b, undefined, {numeric:true}));
    for (const p of prefixes) {
      const opt = document.createElement('option');
      opt.value = p; opt.textContent = p;
      pSel.appendChild(opt);
    }
    // choose barrack first if exists
    const prefer = prefixes.find(p => /barrack/i.test(p)) || prefixes[0] || '';
    if (prefer) setPrefix(prefer);
  }

  async function loadAtlasFromURL(url) {
    setStatus('Loading atlas...', 'ok');
    lastErr = '';
    try {
      const a = await window.PO.atlasTP.loadTPAtlasMulti(url);
      atlas = a;
      framesByPrefix = makePrefixesFromAtlas(a);

      refreshSelectors();
      setStatus(`Loaded: ${a.frames.size} frames, ${a.textures.length} texture(s).`, 'ok');
      setHud();
    } catch (e) {
      lastErr = String(e && e.message ? e.message : e);
      setStatus('Load failed: ' + lastErr, 'bad');
      console.error(e);
      atlas = null;
      framesByPrefix = new Map();
      $('prefixSel').innerHTML = '';
      $('frameSel').innerHTML = '';
      setHud();
    }
  }

  function getIsoConsts() {
    return {
      TILE: parseNum('tile', 128),
      ISO_X: parseNum('isoX', 64),
      ISO_Y: parseNum('isoY', 32),
    };
  }

  function gameWorldToIso(wx, wy, iso) {
    // game.js: isoX = (wx - wy) / TILE; isoY = (wx + wy) / TILE;
    return {
      x: (wx - wy) / iso.TILE,
      y: (wx + wy) / iso.TILE
    };
  }

  function gameWorldToScreen(wx, wy, cam, iso, baseX, baseY) {
    // game.js:
    // ix,iy = worldToIso(wx,wy)
    // sx = (ix - iy) * ISO_X * zoom + baseX - cam.x*zoom
    // sy = (ix + iy) * ISO_Y * zoom + baseY - cam.y*zoom
    const i = gameWorldToIso(wx, wy, iso);
    const sx = (i.x - i.y) * iso.ISO_X * cam.zoom + baseX - cam.x * cam.zoom;
    const sy = (i.x + i.y) * iso.ISO_Y * cam.zoom + baseY - cam.y * cam.zoom;
    return { x:sx, y:sy };
  }

  function tileAnchorToWorld(tx, ty, tw, th, mode, iso) {
    // íƒ€ì¼ ì¢Œí‘œ â†’ ì›”ë“œ(px) ê¸°ì¤€.
    // ê¸°ì¤€: íƒ€ì¼ ì¢Œìƒë‹¨ì„ (tx,ty)ë¡œ ë³¸ë‹¤.
    // center: footprint ì¤‘ì‹¬
    // south: footprint í•˜ë‹¨ ì¤‘ì•™
    let ax = tx;
    let ay = ty;
    if (mode === 'center') {
      ax = tx + (tw * 0.5);
      ay = ty + (th * 0.5);
    } else if (mode === 'south') {
      ax = tx + (tw * 0.5);
      ay = ty + th;
    }
    // world px
    return { x: ax * iso.TILE, y: ay * iso.TILE };
  }

  function drawCross(x, y) {
    ctx.save();
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(121,167,255,.95)';
    ctx.beginPath();
    ctx.moveTo(x-14, y); ctx.lineTo(x+14, y);
    ctx.moveTo(x, y-14); ctx.lineTo(x, y+14);
    ctx.stroke();
    ctx.restore();
  }

  function drawFootprintOverlay(iso, cam) {
    if (!$('showGrid').checked && !$('showFoot').checked) return;

    const w = cv.width / dpr;
    const h = cv.height / dpr;
    const baseX = w * 0.5;
    const baseY = h * clamp(parseNum('baseYRatio', 0.22), 0, 1);

    const tw = parseNum('fpW', 3), th = parseNum('fpH', 2);
    const tx = parseNum('bTX', 0), ty = parseNum('bTY', 0);
    const yDir = ($('fpYDir') ? $('fpYDir').value : 'sw');
    const ySign = (yDir === 'ne') ? -1 : 1; // fy ì¦ê°€ê°€ NEë¡œ ê°€ë©´ -ty

    // ê·¸ë¦¬ë“œ: í™”ë©´ì— ë³´ì´ëŠ” ëŒ€ëµ ë²”ìœ„ë§Œ ê·¸ë ¤ë„ ë˜ì§€ë§Œ, ì—¬ê¸°ì„  ê°„ë‹¨íˆ ì£¼ë³€ë§Œ
    const showGrid = $('showGrid').checked;
    const showFoot = $('showFoot').checked;

    ctx.save();
    ctx.lineWidth = 1;
    ctx.globalAlpha = 0.9;

    const range = 18; // í™”ë©´ì— ë³´ì´ëŠ” ì •ë„ë§Œ
    for (let y = -range; y <= range; y++) {
      for (let x = -range; x <= range; x++) {
        const wx = (x + cam.tileX) * iso.TILE;
        const wy = (y + cam.tileY) * iso.TILE;
        const p = gameWorldToScreen(wx, wy, cam, iso, baseX, baseY);

        const dx = iso.ISO_X * cam.zoom;
        const dy = iso.ISO_Y * cam.zoom;

        if (showGrid) {
          ctx.strokeStyle = 'rgba(70,160,255,.18)';
          ctx.beginPath();
          ctx.moveTo(p.x, p.y - dy);
          ctx.lineTo(p.x + dx, p.y);
          ctx.lineTo(p.x, p.y + dy);
          ctx.lineTo(p.x - dx, p.y);
          ctx.closePath();
          ctx.stroke();
        }
      }
    }

    if (showFoot) {
      // í’‹í”„ë¦°íŠ¸(ìš”êµ¬ì‚¬í•­ ë²„ì „):
      //  - ê°œë³„ ë‹¤ì´ì•„ë¥¼ "í©ë¿Œë¦¬ëŠ”" ëŠë‚Œ ë§ê³ 
      //  - 3x2ë©´ ì‚¬ìš©ì ê·¸ë¦¼ì²˜ëŸ¼ "ì§ì‚¬ê°í˜•(í‰í–‰ì‚¬ë³€í˜•) ì™¸ê³½ + ë‚´ë¶€ 3x2 ë¶„í• "ë¡œ ë³´ì´ê²Œ ê·¸ë¦°ë‹¤.
      const dx = iso.ISO_X * cam.zoom;
      const dy = iso.ISO_Y * cam.zoom;

      // ê¸°ì¤€ì : (tx,ty) íƒ€ì¼ì˜ 'ìƒë‹¨ ê¼­ì§“ì 'ì„ í’‹í”„ë¦°íŠ¸ ì¢Œìƒë‹¨ ì½”ë„ˆë¡œ ì‚¬ìš©
      const c0 = gameWorldToScreen((tx) * iso.TILE, (ty) * iso.TILE, cam, iso, baseX, baseY);
      const P0 = { x: c0.x, y: c0.y - dy };

      // Wì¶•: SE(â†˜) , Hì¶•: SW(â†™)  -> ì‚¬ìš©ì ê·¸ë¦¼ì˜ 3x2 í˜•íƒœ
      const eW = { x: +dx, y: +dy };   // í•œ íƒ€ì¼ë§Œí¼ SEë¡œ ì´ë™(ìƒë‹¨ ê¼­ì§“ì  ê¸°ì¤€)
      const eH = { x: -dx, y: +dy };   // í•œ íƒ€ì¼ë§Œí¼ SWë¡œ ì´ë™(ìƒë‹¨ ê¼­ì§“ì  ê¸°ì¤€)

      const P1 = { x: P0.x + eW.x * tw, y: P0.y + eW.y * tw };
      const P2 = { x: P0.x + eH.x * th, y: P0.y + eH.y * th };
      const P3 = { x: P1.x + eH.x * th, y: P1.y + eH.y * th };

      ctx.save();
      ctx.globalAlpha = 0.95;
      ctx.lineWidth = 3;
      ctx.strokeStyle = 'rgba(108,255,176,.85)';

      // ì™¸ê³½ì„ 
      ctx.beginPath();
      ctx.moveTo(P0.x, P0.y);
      ctx.lineTo(P1.x, P1.y);
      ctx.lineTo(P3.x, P3.y);
      ctx.lineTo(P2.x, P2.y);
      ctx.closePath();
      ctx.stroke();

      // ë‚´ë¶€ ë¶„í• ì„  (ì„¸ë¡œ: Wë°©í–¥ íƒ€ì¼ ê²½ê³„)
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(108,255,176,.65)';
      for (let i = 1; i < tw; i++) {
        const A = { x: P0.x + eW.x * i, y: P0.y + eW.y * i };
        const B = { x: A.x + eH.x * th, y: A.y + eH.y * th };
        ctx.beginPath();
        ctx.moveTo(A.x, A.y);
        ctx.lineTo(B.x, B.y);
        ctx.stroke();
      }
      // ë‚´ë¶€ ë¶„í• ì„  (ê°€ë¡œ: Hë°©í–¥ íƒ€ì¼ ê²½ê³„)
      for (let j = 1; j < th; j++) {
        const A = { x: P0.x + eH.x * j, y: P0.y + eH.y * j };
        const B = { x: A.x + eW.x * tw, y: A.y + eW.y * tw };
        ctx.beginPath();
        ctx.moveTo(A.x, A.y);
        ctx.lineTo(B.x, B.y);
        ctx.stroke();
      }

      ctx.restore();
    }// í’‹í”„ë¦°íŠ¸ "ì§ì‚¬ê°í˜•" ê°€ì´ë“œ(ì™¸ê³½ì„  + ì¶•). ì•„ì´ì†Œì—ì„œëŠ” í‰í–‰ì‚¬ë³€í˜•ìœ¼ë¡œ ë³´ì´ëŠ”ê²Œ ì •ìƒ.
    const showAxis = $('showAxis') ? $('showAxis').checked : false;
    if (showAxis) {
      const pa = gameWorldToScreen((tx) * iso.TILE, (ty) * iso.TILE, cam, iso, baseX, baseY);
      const pb = gameWorldToScreen((tx + tw) * iso.TILE, (ty) * iso.TILE, cam, iso, baseX, baseY);
      const pc = gameWorldToScreen((tx + tw) * iso.TILE, (ty + (ySign * th)) * iso.TILE, cam, iso, baseX, baseY);
      const pd = gameWorldToScreen((tx) * iso.TILE, (ty + (ySign * th)) * iso.TILE, cam, iso, baseX, baseY);

      // outer outline
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,.22)';
      ctx.lineWidth = 2;
      ctx.setLineDash([8, 6]);
      ctx.beginPath();
      ctx.moveTo(pa.x, pa.y);
      ctx.lineTo(pb.x, pb.y);
      ctx.lineTo(pc.x, pc.y);
      ctx.lineTo(pd.x, pd.y);
      ctx.closePath();
      ctx.stroke();
      ctx.setLineDash([]);

      // axis arrows (W: +x â†˜, H: +y â†™)
      function arrow(a, b, label) {
        ctx.strokeStyle = 'rgba(121,167,255,.85)';
        ctx.fillStyle = 'rgba(121,167,255,.85)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();

        const ang = Math.atan2(b.y - a.y, b.x - a.x);
        const ah = 10;
        ctx.beginPath();
        ctx.moveTo(b.x, b.y);
        ctx.lineTo(b.x - Math.cos(ang - 0.55) * ah, b.y - Math.sin(ang - 0.55) * ah);
        ctx.lineTo(b.x - Math.cos(ang + 0.55) * ah, b.y - Math.sin(ang + 0.55) * ah);
        ctx.closePath();
        ctx.fill();

        const mx = (a.x + b.x) * 0.5;
        const my = (a.y + b.y) * 0.5;
        ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
        ctx.fillStyle = 'rgba(255,255,255,.75)';
        ctx.fillText(label, mx + 6, my - 6);
      }

      arrow(pa, pb, `W=${tw}  â†˜(+x)`);
      arrow(pa, pd, (yDir === 'ne') ? `H=${th}  â†—(ty-)` : `H=${th}  â†™(ty+)`);

      // origin dot
      ctx.fillStyle = 'rgba(255,206,106,.85)';
      ctx.beginPath();
      ctx.arc(pa.x, pa.y, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

ctx.restore();
  }


  function drawMiniFootprint() {
    const wrap = $('miniWrap');
    const mini = $('miniCv');
    if (!wrap || !mini) return;

    const on = $('showMini') ? $('showMini').checked : false;
    wrap.style.display = on ? '' : 'none';
    if (!on) return;

    const tw = Math.max(1, parseNum('fpW', 3));
    const th = Math.max(1, parseNum('fpH', 2));
    const mctx = mini.getContext('2d');

    // high DPI crisp
    const mw = mini.width, mh = mini.height;
    mctx.clearRect(0, 0, mw, mh);

    const pad = 18;
    const cell = Math.max(10, Math.floor(Math.min((mw - pad*2) / tw, (mh - pad*2) / th)));
    const w = cell * tw;
    const h = cell * th;
    const ox = Math.floor((mw - w) / 2);
    const oy = Math.floor((mh - h) / 2);

    // fill rect
    mctx.fillStyle = 'rgba(108,255,176,.10)';
    mctx.fillRect(ox, oy, w, h);

    // grid
    mctx.strokeStyle = 'rgba(255,255,255,.18)';
    mctx.lineWidth = 1;
    for (let x = 0; x <= tw; x++) {
      mctx.beginPath();
      mctx.moveTo(ox + x * cell, oy);
      mctx.lineTo(ox + x * cell, oy + h);
      mctx.stroke();
    }
    for (let y = 0; y <= th; y++) {
      mctx.beginPath();
      mctx.moveTo(ox, oy + y * cell);
      mctx.lineTo(ox + w, oy + y * cell);
      mctx.stroke();
    }

    // outline
    mctx.strokeStyle = 'rgba(108,255,176,.85)';
    mctx.lineWidth = 2;
    mctx.strokeRect(ox, oy, w, h);

    // origin marker (0,0)
    mctx.fillStyle = 'rgba(255,206,106,.90)';
    mctx.fillRect(ox + 2, oy + 2, 8, 8);

    // labels
    mctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
    mctx.fillStyle = 'rgba(255,255,255,.78)';
    mctx.fillText(`Top-down: W=${tw} â†’, H=${th} â†“`, 10, 16);
    mctx.fillText(`(0,0) origin`, 10, mh - 10);
  }

  function render() {
    // Ensure size is sane
    if (cv.width < 10 || cv.height < 10) resizeCanvas();

    const w = cv.width / dpr;
    const h = cv.height / dpr;

    ctx.clearRect(0, 0, w, h);

    // subtle vignette
    ctx.save();
    const g = ctx.createRadialGradient(w*0.55, h*0.45, 40, w*0.55, h*0.45, Math.max(w,h)*0.9);
    g.addColorStop(0, 'rgba(255,255,255,0.02)');
    g.addColorStop(1, 'rgba(0,0,0,0.14)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);
    ctx.restore();

    const iso = getIsoConsts();
    const cam = {
      tileX: parseNum('camTX', 0),
      tileY: parseNum('camTY', 0),
      x: parseNum('camTX', 0) * iso.TILE, // world px
      y: parseNum('camTY', 0) * iso.TILE, // world px
      zoom: parseNum('camZoom', 1),
    };

    const baseX = w * 0.5;
    const baseY = h * clamp(parseNum('baseYRatio', 0.22), 0, 1);

    drawFootprintOverlay(iso, cam);
    drawMiniFootprint();

    // draw sprite at anchor
    if (atlas && curFrame) {
      const tw = parseNum('fpW', 3), th = parseNum('fpH', 2);
      const tx = parseNum('bTX', 0), ty = parseNum('bTY', 0);
      const mode = $('anchorMode').value;

      const worldAnchor = tileAnchorToWorld(tx, ty, tw, th, mode, iso);
      const screenAnchor = gameWorldToScreen(worldAnchor.x, worldAnchor.y, cam, iso, baseX, baseY);

      if ($('showAnchor').checked) {
        drawCross(screenAnchor.x, screenAnchor.y);
      }

      const sc = parseNum('scale', 0.14);
      const pivot = {
        x: parseNum('px', 0.5),
        y: parseNum('py', 0.5),
      };

      // IMPORTANT: atlas_tp drawFrame expects x,y = pivot position in screen space.
      // It will internally offset using spriteSourceSize/sourceSize.
      window.PO.atlasTP.drawFrame(ctx, atlas, curFrame, screenAnchor.x, screenAnchor.y, {
        scale: sc,
        pivot,
        debugDraw: $('showBounds').checked
      });

      // output
      $('out').value = JSON.stringify({ x: +pivot.x.toFixed(4), y: +pivot.y.toFixed(4) });
      $('pxVal').textContent = pivot.x.toFixed(4);
      $('pyVal').textContent = pivot.y.toFixed(4);

      const fr = atlas.frames.get(curFrame);
      const ss = fr?.sourceSize || null;
      const sss = fr?.spriteSourceSize || null;
      $('debugLine').textContent =
        `frame=${curFrame}  sourceSize=${ss?`${ss.w}x${ss.h}`:'?'}  spriteSourceSize=${sss?`x=${sss.x},y=${sss.y},w=${sss.w},h=${sss.h}`:'?'}`;
    } else {
      $('out').value = '';
      $('debugLine').textContent = '';
    }

    lastDrawAt = Date.now();
    setHud();
  }

  function tick(now) {
    const fps = clamp(parseNum('fps', 20), 1, 60);
    const dt = now - tPrev;
    tPrev = now;
    if (playing && atlas && curPrefix) {
      acc += dt;
      const stepMs = 1000 / fps;
      if (acc >= stepMs) {
        const list = framesByPrefix.get(curPrefix) || [];
        if (list.length) {
          frameIdx = (frameIdx + 1) % list.length;
          curFrame = list[frameIdx];
          $('frameSel').value = curFrame;
        }
        acc = 0;
      }
    }
    render();
    requestAnimationFrame(tick);
  }

  function applyPivotToPrefix() {
    if (!atlas || !curPrefix) return;
    const list = framesByPrefix.get(curPrefix) || [];
    const pivot = { x: parseNum('px', 0.5), y: parseNum('py', 0.5) };
    for (const name of list) {
      const fr = atlas.frames.get(name);
      if (!fr) continue;
      fr.pivot = { x: pivot.x, y: pivot.y };
      // also write back into original JSON-shaped fields if present
      if (fr._rawFrame && typeof fr._rawFrame === 'object') {
        fr._rawFrame.anchor = { x: pivot.x, y: pivot.y };
      }
    }
    setStatus(`Applied pivot to prefix: ${curPrefix} (${list.length} frames)`, 'ok');
  }

  function downloadPatchedJSON() {
    if (!atlas) return;
    // Rebuild a TexturePacker-like JSON: we stored raw JSON in atlas._rawJson if atlas_tp kept it.
    // atlas_tp.js doesn't keep raw, so we store a copy on load by fetching again.
    // We'll do a safe approach: fetch current jsonUrl, patch "frames[*].anchor" for frames we touched.
    const url = $('jsonUrl').value.trim();
    if (!url) return;
    (async () => {
      try {
        const resp = await fetch(url, { cache:'no-store' });
        const txt = await resp.text();
        if (window.PO.atlasTP && window.PO.atlasTP._looksLikeHTML && window.PO.atlasTP._looksLikeHTML(txt)) {
          throw new Error('JSON URL returned HTML (404/fallback)');
        }
        const j = JSON.parse(txt);
        const list = framesByPrefix.get(curPrefix) || [];
        const pivot = { x: parseNum('px', 0.5), y: parseNum('py', 0.5) };
        const setAnchor = (framesObj) => {
          for (const nm of list) {
            const fr = framesObj[nm];
            if (fr) fr.anchor = { x:pivot.x, y:pivot.y };
          }
        };
        if (j.frames) setAnchor(j.frames);
        if (j.textures && Array.isArray(j.textures)) {
          for (const tex of j.textures) {
            if (tex.frames) setAnchor(tex.frames);
          }
        }
        const blob = new Blob([JSON.stringify(j, null, 2)], { type:'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        const base = url.split('/').pop() || 'atlas.json';
        a.download = base.replace(/\.json$/i,'') + '_patched.json';
        a.click();
        URL.revokeObjectURL(a.href);
        setStatus('Downloaded patched JSON.', 'ok');
      } catch (e) {
        setStatus('Download failed: ' + String(e.message||e), 'bad');
        console.error(e);
      }
    })();
  }

  // ---- wire UI ----
  function bindUI() {
    const bump = (id, delta) => {
      const el = $(id);
      el.value = String(clamp(parseNum(id, 0.5) + delta, 0, 1));
      render();
    };

    $('btnLoad').addEventListener('click', () => loadAtlasFromURL($('jsonUrl').value.trim()));
    $('btnReload').addEventListener('click', () => loadAtlasFromURL($('jsonUrl').value.trim()));

    $('btnIdle').addEventListener('click', () => {
      $('jsonUrl').value = '/asset/sprite/const/normal/barrack/barrack_idle.json';
    });
    $('btnConst').addEventListener('click', () => {
      $('jsonUrl').value = '/asset/sprite/const/const_anim/barrack/barrack_const.json';
    });
    $('btnDist').addEventListener('click', () => {
      $('jsonUrl').value = '/asset/sprite/const/distruct/barrack/barrack_distruct.json';
    });

    $('prefixSel').addEventListener('change', (e) => setPrefix(e.target.value));
    $('frameSel').addEventListener('change', (e) => setFrame(e.target.value));

    $('btnPlay').addEventListener('click', () => { playing = true; });
    $('btnStop').addEventListener('click', () => { playing = false; });

    $('px').addEventListener('input', render);
    $('py').addEventListener('input', render);

    $('pxM').addEventListener('click', () => bump('px', -0.001));
    $('pxP').addEventListener('click', () => bump('px', 0.001));
    $('pyM').addEventListener('click', () => bump('py', -0.001));
    $('pyP').addEventListener('click', () => bump('py', 0.001));

    $('btnApplyPrefix').addEventListener('click', () => { applyPivotToPrefix(); render(); });
    $('btnDownload').addEventListener('click', downloadPatchedJSON);

    // rerender on any numeric/control changes
    const rerenderIds = [
      'fps','scale','tile','isoX','isoY',
      'camTX','camTY','camZoom',
      'fpW','fpH','fpYDir',
      'bTX','bTY',
      'anchorMode','baseYRatio',
      'showGrid','showFoot','showAxis','showAnchor','showBounds','showMini'
    ];
    for (const id of rerenderIds) {
      $(id).addEventListener('input', render);
      $(id).addEventListener('change', render);
    }
  }

  // expose looksLikeHTML helper for download path check
  // (atlas_tp.js does not export it, so we attach a tiny version)
  if (!window.PO.atlasTP._looksLikeHTML) {
    window.PO.atlasTP._looksLikeHTML = (s) => {
      const t = String(s||'').trim().slice(0, 120).toLowerCase();
      return t.startsWith('<!doctype') || t.startsWith('<html') || t.includes('<head') || t.includes('<body');
    };
  }

  function boot() {
    bindUI();
    bootResizeObservers();
    resizeCanvas();
    render();
    requestAnimationFrame(tick);
  }

  if (document.readyState === 'loading') {
    window.addEventListener('DOMContentLoaded', boot);
  } else {
    boot();
  }
})();
</script>
</body>
</html><div class="row"><input id="modeIngame" type="checkbox" checked>
  <label for="modeIngame" style="margin:0;">ì¸ê²Œì„ ì •ë ¬(ë°”ë‹¥ì¤‘ì•™)</label></div>

