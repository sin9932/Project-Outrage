<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Barrack Pivot Tuner (multipack)</title>
  <style>
    :root{color-scheme:dark;}
    body{margin:0;display:flex;height:100vh;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    #left{width:360px;min-width:320px;max-width:420px;overflow:auto;padding:14px 14px 18px;background:#0c111a;border-right:1px solid #1f2a3a;}
    #right{flex:1;position:relative;background:radial-gradient(ellipse at center,#101a2a 0%,#070b12 70%);}
    h1{font-size:18px;margin:0 0 10px;}
    .hint{opacity:.8;font-size:12px;line-height:1.35;margin:0 0 14px;}
    label{display:block;font-size:12px;opacity:.85;margin:10px 0 6px;}
    input,button,textarea{width:100%;box-sizing:border-box;border:1px solid #25334a;background:#0b1220;color:#e6eefc;border-radius:10px;padding:10px 10px;font-size:14px;}
    input{height:38px;}
    textarea{min-height:130px;resize:vertical;font-family:ui-monospace,Consolas,monospace;font-size:12px;line-height:1.3;}
    .row{display:flex;gap:8px;}
    .row > *{flex:1;}
    button{cursor:pointer;background:#0f1b33;border-color:#2b3d5d;}
    button:hover{background:#132243;}
    .small{font-size:12px;padding:9px 10px;}
    .pill{display:inline-block;padding:4px 8px;border:1px solid #2b3d5d;border-radius:999px;font-size:12px;opacity:.9}
    #status{margin-top:10px;font-size:12px;white-space:pre-wrap;opacity:.9}
    canvas{position:absolute;inset:0;margin:auto;display:block;}
    #topBadge{position:absolute;left:12px;top:10px;display:flex;gap:8px;align-items:center;font-size:12px;opacity:.95}
    #topBadge code{background:#0b1220;border:1px solid #2b3d5d;border-radius:8px;padding:4px 8px;}
  </style>
</head>
<body>
  <aside id="left">
    <h1>Pivot Tuner ğŸ› ï¸ (TexturePacker multipack ì§€ì›)</h1>
    <p class="hint">
      - Atlas JSON ì•ˆì˜ <span class="pill">textures[]</span> ë¥¼ ì „ë¶€ ë¡œë“œí•´ì„œ í”„ë ˆì„ì„ í•©ì³ ì¬ìƒí•¨.<br/>
      - í”„ë ˆì„ ì •ë ¬ì€ <b>íŒŒì¼ëª… ëìë¦¬ ìˆ«ì</b> ê¸°ì¤€ (ì˜ˆ: barrack_distruction_12.png).<br/>
      - <b>Apply</b>ëŠ” ë©”ëª¨ë¦¬ìƒì˜ atlasDataë¥¼ ìˆ˜ì •í•˜ê³ , <b>Download JSON</b>ìœ¼ë¡œ ìˆ˜ì •ë³¸ì„ ë‚´ë ¤ë°›ì•„ ë„ˆê°€ í”„ë¡œì íŠ¸ì— ë®ì–´ì“°ë©´ ë¨.
    </p>

    <label>Atlas JSON URL (ì„œë²„ ê²½ë¡œ ë˜ëŠ” ë¡œì»¬ ê²½ë¡œ)</label>
    <input id="atlasUrl" value="/asset/sprite/const/distruct/barrack/barrack_distruct.json"/>

    <label>Frame prefix (ì˜ˆ: barrack_distruction_ / barrack_con_complete_ / barrack_idle)</label>
    <input id="prefix" value="barrack_distruction_"/>

    <div class="row">
      <div>
        <label>FPS</label>
        <input id="fps" type="number" value="12" min="1" max="120"/>
      </div>
      <div>
        <label>Zoom</label>
        <input id="zoom" type="number" value="0.35" step="0.05" min="0.05" max="6"/>
      </div>
    </div>

    <div class="row">
      <div>
        <label>Pivot X (0~1)</label>
        <input id="pivotX" type="number" value="0.5" step="0.01" min="0" max="1"/>
      </div>
      <div>
        <label>Pivot Y (0~1)</label>
        <input id="pivotY" type="number" value="0.52" step="0.01" min="0" max="1"/>
      </div>
    </div>

    <div class="row">
      <button id="btnLoad" class="small">Load</button>
      <button id="btnPlay" class="small">Play</button>
      <button id="btnPrev" class="small">â—€</button>
      <button id="btnNext" class="small">â–¶</button>
    </div>

    <div class="row" style="margin-top:8px">
      <button id="btnApplyCur" class="small">Apply to current</button>
      <button id="btnApplyAll" class="small">Apply to all</button>
    </div>

    <div class="row" style="margin-top:8px">
      <button id="btnDownload" class="small">Download patched JSON</button>
      <button id="btnCopyJS" class="small">Copy JS override</button>
    </div>

    <label>Footprint overlay (íƒ€ì¼ 3x2 ê¸°ë³¸)</label>
    <div class="row">
      <div><input id="tileW" type="number" value="128"/></div>
      <div><input id="tileH" type="number" value="64"/></div>
    </div>
    <div class="row">
      <div><input id="tilesX" type="number" value="3"/></div>
      <div><input id="tilesY" type="number" value="2"/></div>
    </div>

    <label>Copy/paste output</label>
    <textarea id="out" spellcheck="false"></textarea>

    <div id="status">Idle</div>
  </aside>

  <main id="right">
    <div id="topBadge"><span class="pill" id="frameInfo">No frames</span><code id="texInfo">textures:0</code></div>
    <canvas id="cv"></canvas>
  </main>

<script>
'use strict';
const $ = (id)=>document.getElementById(id);
const cv = $('cv');
const ctx = cv.getContext('2d');

function clamp01(n){ n = Number(n); if(!Number.isFinite(n)) return 0; return Math.max(0, Math.min(1, n)); }
function numOr(id, fallback){ const n = Number($(id).value); return Number.isFinite(n) ? n : fallback; }
function dirname(path){ const q = path.split('?')[0]; const i = q.lastIndexOf('/'); return i>=0 ? q.slice(0,i+1) : ''; }

function extractTrailingNumber(name){
  // name like "barrack_distruction_12.png" or "barrack_con_complete_3.png"
  const m = name.match(/(\d+)(?=\.png$)/i);
  if(!m) return null;
  return Number(m[1]);
}

let atlasData = null;
let basePath = '';
let textures = []; // {img, name}
let frames = [];   // merged frames for given prefix: [{name, texIndex, frame, sourceSize, spriteSourceSize, rotated, anchor}]
let playing = false;
let cur = 0;
let lastT = 0;

function setStatus(msg){ $('status').textContent = msg; }
function setInfo(){
  $('texInfo').textContent = `textures:${textures.length}`;
  if(frames.length){
    const f = frames[cur];
    $('frameInfo').textContent = `${f.name}  [${cur+1}/${frames.length}]  tex:${f.texIndex}`;
  } else {
    $('frameInfo').textContent = `No frames`;
  }
}

// ---- Pivot overrides persistence (for game runtime) ----
// Saved under localStorage key: "PO_PIVOT_OVERRIDES"
// Format: { "<prefix>": { "x": 0.5, "y": 0.5 }, ... }
const LS_PIVOT_KEY = "PO_PIVOT_OVERRIDES";

function loadPivotOverridesLS(){
  try{
    return JSON.parse(localStorage.getItem(LS_PIVOT_KEY) || "{}") || {};
  }catch(_e){
    return {};
  }
}

function savePivotOverridesLS(obj){
  try{
    localStorage.setItem(LS_PIVOT_KEY, JSON.stringify(obj));
    return true;
  }catch(_e){
    return false;
  }
}

function persistPrefixPivot(prefix, x, y){
  const p = (prefix || "").trim();
  if(!p) return { ok:false, reason:"prefix empty" };
  const obj = loadPivotOverridesLS();
  obj[p] = { x, y };
  const ok = savePivotOverridesLS(obj);
  return { ok, reason: ok ? "saved" : "localStorage blocked" };
}



function resizeCanvas(){
  const r = $('right').getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  cv.width = Math.floor(r.width * dpr);
  cv.height = Math.floor(r.height * dpr);
  cv.style.width = r.width + 'px';
  cv.style.height = r.height + 'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', resizeCanvas);

function drawDiamondGrid(cx, cy, tileW, tileH, tilesX, tilesY){
  // isometric diamond footprint centered at (cx,cy)
  ctx.save();
  ctx.translate(cx, cy);
  ctx.globalAlpha = 0.75;
  ctx.strokeStyle = 'rgba(100,170,255,0.8)';
  ctx.lineWidth = 1;

  // footprint extents in iso space
  for(let y=0;y<tilesY;y++){
    for(let x=0;x<tilesX;x++){
      const ox = (x - y) * (tileW/2);
      const oy = (x + y) * (tileH/2);
      ctx.beginPath();
      ctx.moveTo(ox, oy - tileH/2);
      ctx.lineTo(ox + tileW/2, oy);
      ctx.lineTo(ox, oy + tileH/2);
      ctx.lineTo(ox - tileW/2, oy);
      ctx.closePath();
      ctx.stroke();
    }
  }
  ctx.restore();
}

function buildUntrimmedCanvas(f){
  const fullW = f.sourceSize?.w ?? f.frame.w;
  const fullH = f.sourceSize?.h ?? f.frame.h;
  const off = document.createElement('canvas');
  off.width = fullW;
  off.height = fullH;
  const octx = off.getContext('2d');

  const tex = textures[f.texIndex]?.img;
  if(!tex) return {canvas:off, w:fullW, h:fullH};

  // draw trimmed region into untrimmed
  const fr = f.frame;
  const ss = f.spriteSourceSize ?? {x:0,y:0,w:fr.w,h:fr.h};

  if(f.rotated){
    // TexturePacker rotation: frame.w/h are swapped in atlas; handle by rotating draw
    // We draw into a temp canvas, then rotate into destination.
    const temp = document.createElement('canvas');
    temp.width = fr.w;
    temp.height = fr.h;
    const tctx = temp.getContext('2d');
    // For rotated sprites, many TP exports store width/height swapped; this is a best-effort.
    tctx.save();
    // draw the atlas region directly
    tctx.drawImage(tex, fr.x, fr.y, fr.w, fr.h, 0, 0, fr.w, fr.h);
    tctx.restore();

    octx.save();
    // rotate -90 degrees into destination at ss.x/y
    octx.translate(ss.x, ss.y);
    octx.translate(temp.width/2, temp.height/2);
    octx.rotate(-Math.PI/2);
    octx.translate(-temp.height/2, -temp.width/2);
    octx.drawImage(temp, 0, 0);
    octx.restore();
  } else {
    octx.drawImage(tex, fr.x, fr.y, fr.w, fr.h, ss.x, ss.y, ss.w, ss.h);
  }

  return {canvas:off, w:fullW, h:fullH};
}

function render(){
  const r = $('right').getBoundingClientRect();
  ctx.clearRect(0,0,r.width,r.height);

  const cx = r.width/2;
  const cy = r.height/2;

  const tileW = numOr('tileW',128);
  const tileH = numOr('tileH',64);
  const tilesX = numOr('tilesX',3);
  const tilesY = numOr('tilesY',2);

  drawDiamondGrid(cx, cy, tileW, tileH, tilesX, tilesY);

  if(!frames.length) return;

  const f = frames[cur];
  const z = numOr('zoom',1);
  const px = clamp01($('pivotX').value);
  const py = clamp01($('pivotY').value);

  // use frame's own anchor if available unless user is actively applying; we show current input pivot values for tuning
  const {canvas, w, h} = buildUntrimmedCanvas(f);

  const drawW = w * z;
  const drawH = h * z;

  // pivot point at center of footprint (cx,cy)
  const dx = cx - (px * drawW);
  const dy = cy - (py * drawH);

  ctx.save();
  ctx.globalAlpha = 1;
  ctx.imageSmoothingEnabled = true;
  ctx.drawImage(canvas, dx, dy, drawW, drawH);

  // pivot crosshair
  const pivotX = cx;
  const pivotY = cy;
  ctx.strokeStyle = 'rgba(255,220,120,0.95)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(pivotX-10, pivotY);
  ctx.lineTo(pivotX+10, pivotY);
  ctx.moveTo(pivotX, pivotY-10);
  ctx.lineTo(pivotX, pivotY+10);
  ctx.stroke();

  // bounding box
  ctx.strokeStyle = 'rgba(255,190,80,0.55)';
  ctx.lineWidth = 1;
  ctx.strokeRect(dx, dy, drawW, drawH);
  ctx.restore();

  setInfo();
}

function tick(ts){
  if(!playing){ render(); return; }
  const fps = Math.max(1, numOr('fps',12));
  const step = 1000 / fps;
  if(!lastT) lastT = ts;
  const dt = ts - lastT;
  if(dt >= step){
    lastT = ts - (dt % step);
    cur = (cur + 1) % Math.max(1, frames.length);
  }
  render();
  requestAnimationFrame(tick);
}

function rebuildFramesByPrefix(){
  if(!atlasData) { frames=[]; return; }
  const prefix = $('prefix').value.trim();
  const list = [];
  atlasData.textures.forEach((tex, texIndex)=>{
    (tex.frames||[]).forEach(fr=>{
      const name = fr.filename;
      if(!prefix || name.startsWith(prefix)){
        list.push({
          name,
          texIndex,
          frame: fr.frame,
          rotated: !!fr.rotated,
          sourceSize: fr.sourceSize,
          spriteSourceSize: fr.spriteSourceSize,
          anchor: fr.anchor ? {x: fr.anchor.x, y: fr.anchor.y} : {x:0.5,y:0.5},
          _ref: fr
        });
      }
    });
  });

  // sort by trailing number if exists, else stable by name
  list.sort((a,b)=>{
    const na = extractTrailingNumber(a.name);
    const nb = extractTrailingNumber(b.name);
    if(na!=null && nb!=null) return na-nb;
    if(na!=null && nb==null) return -1;
    if(na==null && nb!=null) return 1;
    return a.name.localeCompare(b.name);
  });

  frames = list;
  cur = 0;
  lastT = 0;
  setInfo();
}

async function loadAtlas(){
  setStatus('Loading atlas JSON...');
  const url = $('atlasUrl').value.trim();
  if(!url){ setStatus('ERR: atlasUrl empty'); return; }

  basePath = dirname(url);
  try{
    const res = await fetch(url, {cache:'no-store'});
    if(!res.ok) throw new Error(`${res.status} ${res.statusText}`);
    atlasData = await res.json();
  }catch(e){
    setStatus('ERR: atlas json fetch ì‹¤íŒ¨\n' + e.message);
    atlasData = null;
    return;
  }

  if(!atlasData.textures || !Array.isArray(atlasData.textures)){
    setStatus('ERR: textures[] ì—†ëŠ” atlas jsonì„');
    return;
  }

  // load images
  textures = [];
  const promises = atlasData.textures.map((t, i)=>{
    return new Promise((resolve,reject)=>{
      const img = new Image();
      img.onload = ()=>resolve({img, name:t.image});
      img.onerror = ()=>reject(new Error('image load fail: ' + t.image));
      img.src = basePath + t.image;
    });
  });

  try{
    const loaded = await Promise.all(promises);
    textures = loaded;
  }catch(e){
    setStatus('ERR: atlas image ë¡œë“œ ì‹¤íŒ¨\n' + e.message + '\n(basePath=' + basePath + ')');
    return;
  }

  rebuildFramesByPrefix();

  $('out').value = '';
  setStatus(`Loaded OK\nbasePath=${basePath}\ntextures=${textures.length}\nframes=${frames.length}`);
  render();
}

function applyPivotTo(names){
  if(!atlasData) return;
  const x = clamp01($('pivotX').value);
  const y = clamp01($('pivotY').value);

  const nameSet = new Set(names);
  atlasData.textures.forEach(tex=>{
    tex.frames.forEach(fr=>{
      if(nameSet.has(fr.filename)){
        fr.anchor = {x, y};
      }
    });
  });

  // also update frames list cached anchor (optional)
  frames.forEach(f=>{
    if(nameSet.has(f.name)){
      f.anchor = {x,y};
      if(f._ref) f._ref.anchor = {x,y};
    }
  });

  const prefix = $('prefix').value;
  const persist = persistPrefixPivot(prefix, x, y);
  const note = persist.ok ? ` + saved to localStorage (${LS_PIVOT_KEY}) for prefix: "${prefix.trim()}"` : ` (not saved: ${persist.reason})`;
  setStatus(`Applied pivot (${x.toFixed(3)},${y.toFixed(3)}) to ${names.length} frame(s).` + note);
}

function applyCurrent(){
  if(!frames.length) return;
  applyPivotTo([frames[cur].name]);
}
function applyAll(){
  if(!frames.length) return;
  applyPivotTo(frames.map(f=>f.name));
}

function downloadPatched(){
  if(!atlasData) { setStatus('ERR: atlas not loaded'); return; }
  const url = $('atlasUrl').value.trim();
  const filename = (url.split('?')[0].split('/').pop() || 'atlas_patched.json');
  const blob = new Blob([JSON.stringify(atlasData, null, 2)], {type:'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setStatus('Downloaded patched JSON: ' + filename + '\n(ì´ íŒŒì¼ì„ í”„ë¡œì íŠ¸ì˜ atlas jsonì— ë®ì–´ì“°ë©´ "í”¼ë²— ë°•ê¸°" ì™„ë£Œ)');
}

function copyJSOverride(){
  const x = clamp01($('pivotX').value);
  const y = clamp01($('pivotY').value);
  const prefix = $('prefix').value.trim();
  const s =
`// paste into your client code (once), then call applyAtlasPivotOverride(atlasJson, PIVOTS)
const PIVOTS = [
  { prefix: ${JSON.stringify(prefix)}, x: ${x.toFixed(3)}, y: ${y.toFixed(3)} },
];

function applyAtlasPivotOverride(atlas, pivots){
  if(!atlas?.textures) return;
  for(const tex of atlas.textures){
    for(const fr of (tex.frames||[])){
      for(const p of pivots){
        if(p.prefix && fr.filename.startsWith(p.prefix)){
          fr.anchor = { x: p.x, y: p.y };
          break;
        }
      }
    }
  }
}`;
  $('out').value = s;
  navigator.clipboard?.writeText(s).catch(()=>{});
  setStatus('Copied JS override snippet to output (and clipboard if allowed).');
}

$('btnLoad').addEventListener('click', ()=>loadAtlas());
$('btnPlay').addEventListener('click', ()=>{
  playing = !playing;
  $('btnPlay').textContent = playing ? 'Pause' : 'Play';
  if(playing){ lastT = 0; requestAnimationFrame(tick); }
  else { render(); }
});
$('btnPrev').addEventListener('click', ()=>{
  if(!frames.length) return;
  cur = (cur - 1 + frames.length) % frames.length;
  render();
});
$('btnNext').addEventListener('click', ()=>{
  if(!frames.length) return;
  cur = (cur + 1) % frames.length;
  render();
});
$('btnApplyCur').addEventListener('click', applyCurrent);
$('btnApplyAll').addEventListener('click', applyAll);
$('btnDownload').addEventListener('click', downloadPatched);
$('btnCopyJS').addEventListener('click', copyJSOverride);

$('prefix').addEventListener('change', ()=>{
  rebuildFramesByPrefix();
  render();
});
['pivotX','pivotY','zoom','tileW','tileH','tilesX','tilesY'].forEach(id=>{
  $(id).addEventListener('input', ()=>render());
});

resizeCanvas();
render();
</script>
</body>
</html>
