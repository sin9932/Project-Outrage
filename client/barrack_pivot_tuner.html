<!DOCTYPE html>

<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>Pivot Tuner (Multi-Texture)</title>
<style>
    :root{color-scheme:dark;}
    body{margin:0;font-family:system-ui,Segoe UI,Apple SD Gothic Neo,Malgun Gothic,sans-serif;background:#0b0f16;color:#e6edf6;}
    .wrap{display:grid;grid-template-columns:360px 1fr;height:100vh;}
    .panel{padding:14px 12px;border-right:1px solid rgba(255,255,255,.08);overflow:auto;background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,0));}
    h1{font-size:18px;margin:0 0 10px 0;}
    label{display:block;font-size:12px;opacity:.85;margin:10px 0 6px;}
    input[type=text], input[type=number]{width:100%;box-sizing:border-box;padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.04);color:#e6edf6;outline:none;}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
    .btns{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px;}
    button{padding:10px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.06);color:#e6edf6;cursor:pointer;}
    button:hover{background:rgba(255,255,255,.10);}
    .hint{font-size:12px;opacity:.75;line-height:1.4;margin-top:8px;}
    .err{font-size:12px;color:#ff6b6b;white-space:pre-wrap;margin-top:10px;}
    .ok{font-size:12px;color:#7ee787;white-space:pre-wrap;margin-top:10px;}
    textarea{width:100%;min-height:140px;box-sizing:border-box;padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.04);color:#e6edf6;outline:none;resize:vertical;}
    canvas{width:100%;height:100%;display:block;}
    .stage{position:relative;}
    .badge{position:absolute;left:14px;top:12px;padding:6px 10px;border-radius:999px;font-size:12px;background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.1);backdrop-filter:blur(6px);}
    .badge span{opacity:.85}
  </style>
</head>
<body>
<div class="wrap">
<div class="panel">
<h1>Pivot Tuner ğŸ”§</h1>
<div class="hint">
      TexturePacker <b>multipack(textures ë°°ì—´)</b> ì§€ì›.<br/>
      í”„ë ˆì„ì€ <b>ëìë¦¬ ìˆ«ì</b> ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬í•´ì„œ ì¬ìƒí•´.<br/>
      ìº”ë²„ìŠ¤ì—ì„œ <b>í´ë¦­</b>í•˜ë©´ í˜„ì¬ í”„ë ˆì„ì˜ Pivot(anchor)ì„ ì°ê³ , <b>Shift+í´ë¦­</b>í•˜ë©´ ì „ì²´ í”„ë ˆì„ì— ì ìš©.
    </div>
<label>Atlas JSON URL (ì„œë²„ ê²½ë¡œ)</label>
<input id="atlasUrl" type="text" value="/asset/sprite/const/distruct/barrack/barrack_distruct.json"/>
<label>Base path (ë¹„ìš°ë©´ JSON ê²½ë¡œì—ì„œ ìë™ ì¶”ì¶œ)</label>
<input id="basePath" placeholder="ì˜ˆ: /asset/sprite/const/distruct/barrack/" type="text"/>
<label>Frame prefix (ì˜ˆ: barrack_distruction_)</label>
<input id="prefix" type="text" value="barrack_distruction_"/>
<div class="btns">
<button id="btnLoad">Load</button>
<button id="btnPlay">Play</button>
<button id="btnPrev">â—€</button>
<button id="btnNext">â–¶</button>
</div>
<div class="row">
<div>
<label>FPS</label>
<input id="fps" max="60" min="1" type="number" value="10"/>
</div>
<div>
<label>Zoom</label>
<input id="zoom" max="6" min="0.1" step="0.05" type="number" value="1"/>
</div>
</div>
<div class="row">
<div>
<label>Pivot X (normalized)</label>
<input id="pivotX" max="1" min="0" step="0.001" type="number" value="0.5"/>
</div>
<div>
<label>Pivot Y (normalized)</label>
<input id="pivotY" max="1" min="0" step="0.001" type="number" value="0.52"/>
</div>
</div>
<div class="btns">
<button id="btnApplyCur">Apply to current</button>
<button id="btnApplyAll">Apply to all</button>
<button id="btnCopy">Copy output</button>
<button id="btnSavePrefix">Save prefix pivot</button><button id="btnCopyOverrides">Copy overrides JSON</button><button id="btnSaveLS">Save to localStorage</button><button id="btnLoadLS">Load from localStorage</button></div>
<label>Footprint overlay (3x2)</label>
<div class="row">
<div><label style="margin-top:0">TileW</label><input id="tileW" type="number" value="128"/></div>
<div><label style="margin-top:0">TileH</label><input id="tileH" type="number" value="64"/></div>
</div>
<div class="row">
<div><label>TilesX</label><input id="tilesX" type="number" value="3"/></div>
<div><label>TilesY</label><input id="tilesY" type="number" value="2"/></div>
</div>
<label>Copy/paste output (frameName -&gt; pivot)</label>
<textarea id="out" spellcheck="false"></textarea>
<div class="err" id="status"></div>
</div>
<div class="stage">
<div class="badge"><span id="badgeText">Not loaded</span></div>
<canvas id="cv"></canvas>
</div>
</div>
<script>
/** Minimal TexturePacker JSON helper (multipack supported)
 * Expects TP "Unity" style JSON:
 * { textures:[{image,size,frames:[{filename,frame,spriteSourceSize,sourceSize,rotated,trimmed,anchor?}]}] }
 */
const TP = (() => {
  const reTailNum = /(\d+)(?=\.[a-z0-9]+$)/i;
  function numericSuffix(name){
    const m = name.match(reTailNum);
    return m ? parseInt(m[1],10) : null;
  }
  function normalizeBasePath(atlasUrl, basePathInput){
    if (basePathInput && basePathInput.trim()) return basePathInput.trim().replace(/\\/g,'/');
    const u = atlasUrl.trim().replace(/\\/g,'/');
    const idx = u.lastIndexOf('/');
    return idx>=0 ? u.slice(0, idx+1) : '';
  }
  function flattenFrames(atlas){
    const out = [];
    const textures = atlas.textures || [];
    textures.forEach((tex, texIdx) => {
      (tex.frames||[]).forEach(fr => {
        out.push({ name: fr.filename, texIdx, fr });
      });
    });
    return out;
  }
  function listFramesByPrefix(atlas, prefix){
    const all = flattenFrames(atlas);
    const wanted = all.filter(x => x.name.startsWith(prefix));
    wanted.sort((a,b)=>{
      const na = numericSuffix(a.name); const nb = numericSuffix(b.name);
      if (na==null && nb==null) return a.name.localeCompare(b.name);
      if (na==null) return 1;
      if (nb==null) return -1;
      return na-nb;
    });
    return wanted;
  }
  return { normalizeBasePath, listFramesByPrefix };
})();

const $ = (id)=>document.getElementById(id);
const cv = $('cv');
const ctx = cv.getContext('2d');

let state = {
  atlasUrl: '',
  basePath: '',
  prefix: '',
  atlas: null,
  textures: [], // {imageName, img}
  frameList: [], // [{name,texIdx,fr}]
  frameIdx: 0,
  playing: false,
  lastT: 0,
  acc: 0,
  anchors: new Map(),
};

function setStatus(msg, ok=false){
  const el = $('status');
  el.className = ok ? 'ok' : 'err';
  el.textContent = msg || '';
}

function resize(){
  const rect = cv.getBoundingClientRect();
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  cv.width = Math.floor(rect.width * dpr);
  cv.height = Math.floor(rect.height * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
  draw();
}
window.addEventListener('resize', resize);

async function fetchJson(url){
  const res = await fetch(url, {cache:'no-store'});
  if (!res.ok) throw new Error(`JSON fetch failed: ${res.status} ${res.statusText}\n${url}`);
  return await res.json();
}

async function loadImage(url){
  return await new Promise((resolve,reject)=>{
    const img = new Image();
    img.onload=()=>resolve(img);
    img.onerror=()=>reject(new Error(`Image load failed: ${url}`));
    img.src=url;
  });
}

function currentFrame(){
  if (!state.frameList.length) return null;
  return state.frameList[state.frameIdx];
}

function effectiveAnchor(frameName, fr){
  if (state.anchors.has(frameName)) return state.anchors.get(frameName);
  if (fr.anchor && typeof fr.anchor.x==='number' && typeof fr.anchor.y==='number') return {x:fr.anchor.x,y:fr.anchor.y};
  return {x:0.5,y:0.5};
}

function setBadge(text){ $('badgeText').textContent = text; }
function fmt(n){ return (Math.round(n*1000)/1000).toFixed(3); }
function parseNum(v, d){ const n = Number(v); return Number.isFinite(n)?n:d; }

function outputText(){
  const lines = state.frameList.map(x=>{
    const a = effectiveAnchor(x.name, x.fr);
    return `${x.name}: { x: ${fmt(a.x)}, y: ${fmt(a.y)} }`;
  });
  $('out').value = lines.join('\n');
}

function drawIsoFootprint(cx, cy, tileW, tileH, tilesX, tilesY){
  ctx.save();
  ctx.globalAlpha = 0.8;
  ctx.lineWidth = 1;
  ctx.strokeStyle = 'rgba(120,180,255,.45)';
  ctx.fillStyle = 'rgba(80,140,220,.08)';

  const totalW = (tilesX + tilesY) * (tileW/2);
  const totalH = (tilesX + tilesY) * (tileH/2);
  const originX = cx - totalW/2;
  const originY = cy - totalH/2;

  for (let ty=0; ty<tilesY; ty++){
    for (let tx=0; tx<tilesX; tx++){
      const px = originX + (tx - ty) * (tileW/2) + totalW/2;
      const py = originY + (tx + ty) * (tileH/2) + totalH/4;
      ctx.beginPath();
      ctx.moveTo(px, py - tileH/2);
      ctx.lineTo(px + tileW/2, py);
      ctx.lineTo(px, py + tileH/2);
      ctx.lineTo(px - tileW/2, py);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    }
  }
  ctx.restore();
}

function draw(){
  const frWrap = currentFrame();
  ctx.clearRect(0,0,cv.width,cv.height);
  if (!frWrap || !state.atlas) return;

  const zoom = parseNum($('zoom').value, 1);
  const tileW = parseNum($('tileW').value, 128);
  const tileH = parseNum($('tileH').value, 64);
  const tilesX = parseNum($('tilesX').value, 3);
  const tilesY = parseNum($('tilesY').value, 2);

  const {name, texIdx, fr} = frWrap;
  const img = state.textures[texIdx]?.img;
  if (!img) return;

  const srcW = fr.sourceSize?.w ?? fr.frame.w;
  const srcH = fr.sourceSize?.h ?? fr.frame.h;
  const ss = fr.spriteSourceSize || {x:0,y:0,w:fr.frame.w,h:fr.frame.h};

  const a = effectiveAnchor(name, fr);
  const pivotSrcX = a.x * srcW;
  const pivotSrcY = a.y * srcH;
  const pivotTrimX = pivotSrcX - ss.x;
  const pivotTrimY = pivotSrcY - ss.y;

  const rect = cv.getBoundingClientRect();
  const cx = rect.width/2;
  const cy = rect.height/2;
  const drawX = cx - pivotTrimX * zoom;
  const drawY = cy - pivotTrimY * zoom;

  drawIsoFootprint(cx, cy, tileW, tileH, tilesX, tilesY);

  ctx.save();
  ctx.imageSmoothingEnabled = true;
  if (fr.rotated){
    const fw = fr.frame.w, fh = fr.frame.h;
    ctx.translate(drawX + fw*zoom/2, drawY + fh*zoom/2);
    ctx.rotate(-Math.PI/2);
    ctx.drawImage(img, fr.frame.x, fr.frame.y, fw, fh, (-fh/2)*zoom, (-fw/2)*zoom, fh*zoom, fw*zoom);
    ctx.setTransform(1,0,0,1,0,0);
  } else {
    ctx.drawImage(img, fr.frame.x, fr.frame.y, fr.frame.w, fr.frame.h, drawX, drawY, fr.frame.w*zoom, fr.frame.h*zoom);
  }

  // pivot crosshair
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,.85)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(cx-10, cy); ctx.lineTo(cx+10, cy);
  ctx.moveTo(cx, cy-10); ctx.lineTo(cx, cy+10);
  ctx.stroke();
  ctx.restore();

  // bbox
  ctx.save();
  ctx.strokeStyle = 'rgba(255,200,0,.35)';
  ctx.lineWidth = 1;
  ctx.strokeRect(drawX, drawY, fr.frame.w*zoom, fr.frame.h*zoom);
  ctx.restore();

  ctx.restore();

  setBadge(`${name}  [tex ${texIdx}]  pivot=(${fmt(a.x)},${fmt(a.y)})  frame=${state.frameIdx+1}/${state.frameList.length}`);
}

function stepFrame(dir){
  if (!state.frameList.length) return;
  state.frameIdx = (state.frameIdx + dir + state.frameList.length) % state.frameList.length;
  const frWrap = currentFrame();
  const a = effectiveAnchor(frWrap.name, frWrap.fr);
  $('pivotX').value = a.x;
  $('pivotY').value = a.y;
  draw();
}

function tick(t){
  if (!state.playing){ requestAnimationFrame(tick); return; }
  if (!state.lastT) state.lastT = t;
  const dt = (t - state.lastT) / 1000;
  state.lastT = t;

  const fps = Math.max(1, Math.min(60, parseNum($('fps').value, 10)));
  const spf = 1 / fps;
  state.acc += dt;
  while (state.acc >= spf){
    state.acc -= spf;
    stepFrame(1);
  }
  requestAnimationFrame(tick);
}

function applyTo(names){
  const x = Math.max(0, Math.min(1, parseNum($('pivotX').value, 0.5)));
  const y = Math.max(0, Math.min(1, parseNum($('pivotY').value, 0.5)));
  names.forEach(n=>state.anchors.set(n,{x,y}));
  outputText();
  draw();
}

async function load(){
  try{
    setStatus('Loading...', true);
    state.atlasUrl = $('atlasUrl').value.trim();
    state.prefix = $('prefix').value.trim();
    if (!state.atlasUrl) throw new Error('Atlas URL ë¹„ì—ˆìŒ');

    const atlas = await fetchJson(state.atlasUrl);
    state.atlas = atlas;

    state.basePath = TP.normalizeBasePath(state.atlasUrl, $('basePath').value);
    $('basePath').value = state.basePath;

    const textures = atlas.textures || [];
    if (!textures.length) throw new Error('atlas.textures ì—†ìŒ (TexturePacker JSON ë§ëŠ”ì§€ í™•ì¸)');

    state.textures = [];
    for (let i=0;i<textures.length;i++){
      const imgName = textures[i].image;
      const imgUrl = state.basePath + imgName;
      const img = await loadImage(imgUrl);
      state.textures.push({imageName: imgName, img});
    }

    const list = TP.listFramesByPrefix(atlas, state.prefix);
    if (!list.length) throw new Error(`prefixë¡œ í”„ë ˆì„ 0ê°œ: ${state.prefix}`);

    state.frameList = list;
    state.frameIdx = 0;

    const first = currentFrame();
    const a = effectiveAnchor(first.name, first.fr);
    $('pivotX').value = a.x;
    $('pivotY').value = a.y;

    state.playing = false;
    state.lastT = 0;
    state.acc = 0;

    outputText();
    setStatus(`Loaded OK\ntextures=${state.textures.length}\nframes=${state.frameList.length}`, true);
    resize();
  }catch(e){
    console.error(e);
    setStatus(String(e), false);
  }
}

$('btnLoad').addEventListener('click', load);
$('btnPlay').addEventListener('click', ()=>{
  state.playing = !state.playing;
  $('btnPlay').textContent = state.playing ? 'Pause' : 'Play';
});
$('btnPrev').addEventListener('click', ()=>stepFrame(-1));
$('btnNext').addEventListener('click', ()=>stepFrame(1));
$('btnApplyCur').addEventListener('click', ()=>{ const fr = currentFrame(); if (fr) applyTo([fr.name]); });
$('btnApplyAll').addEventListener('click', ()=>applyTo(state.frameList.map(x=>x.name)));
$('btnCopy').addEventListener('click', async ()=>{
  try{ await navigator.clipboard.writeText($('out').value); setStatus('Copied âœ…', true); }
  catch{ setStatus('Copy ì‹¤íŒ¨. í…ìŠ¤íŠ¸ ì˜ì—­ì—ì„œ ìˆ˜ë™ ë³µì‚¬í•´.', false); }
});

['pivotX','pivotY','zoom','tileW','tileH','tilesX','tilesY'].forEach(id=>$(id).addEventListener('input', draw));

cv.addEventListener('click', (ev)=>{
  const frWrap = currentFrame();
  if (!frWrap) return;
  const {name, fr} = frWrap;

  const rect = cv.getBoundingClientRect();
  const zoom = parseNum($('zoom').value, 1);
  const srcW = fr.sourceSize?.w ?? fr.frame.w;
  const srcH = fr.sourceSize?.h ?? fr.frame.h;
  const ss = fr.spriteSourceSize || {x:0,y:0,w:fr.frame.w,h:fr.frame.h};

  const a = effectiveAnchor(name, fr);
  const pivotSrcX = a.x * srcW;
  const pivotSrcY = a.y * srcH;
  const pivotTrimX = pivotSrcX - ss.x;
  const pivotTrimY = pivotSrcY - ss.y;

  const cx = rect.width/2;
  const cy = rect.height/2;
  const drawX = cx - pivotTrimX * zoom;
  const drawY = cy - pivotTrimY * zoom;

  const mx = ev.clientX - rect.left;
  const my = ev.clientY - rect.top;
  const trimX = (mx - drawX) / zoom;
  const trimY = (my - drawY) / zoom;
  const srcX = trimX + ss.x;
  const srcY = trimY + ss.y;

  const newAx = Math.max(0, Math.min(1, srcX / srcW));
  const newAy = Math.max(0, Math.min(1, srcY / srcH));

  $('pivotX').value = newAx;
  $('pivotY').value = newAy;

  if (ev.shiftKey) applyTo(state.frameList.map(x=>x.name));
  else applyTo([name]);
});

requestAnimationFrame(tick);
resize();


  // ---- Pivot overrides (prefix -> pivot) helpers ----
  let pivotOverrides = {};
  function readOverridesFromLS(){
    try{
      const raw = localStorage.getItem('PO_PIVOT_OVERRIDES');
      if (!raw) return {};
      const obj = JSON.parse(raw);
      return (obj && typeof obj === 'object') ? obj : {};
    }catch(e){
      return {};
    }
  }
  function writeOverridesToLS(obj){
    try{
      localStorage.setItem('PO_PIVOT_OVERRIDES', JSON.stringify(obj, null, 2));
      return true;
    }catch(e){
      return false;
    }
  }
  pivotOverrides = readOverridesFromLS();

  const btnSavePrefix = document.getElementById('btnSavePrefix');
  const btnCopyOverrides = document.getElementById('btnCopyOverrides');
  const btnSaveLS = document.getElementById('btnSaveLS');
  const btnLoadLS = document.getElementById('btnLoadLS');

  function currentPrefix(){
    return (elPrefix.value || '').trim();
  }
  function currentPivot(){
    return { x: Number(elPivotX.value), y: Number(elPivotY.value) };
  }

  if (btnSavePrefix){
    btnSavePrefix.addEventListener('click', ()=>{
      const p = currentPrefix();
      if (!p){
        setStatus('ERR: prefix is empty');
        return;
      }
      pivotOverrides[p] = currentPivot();
      setStatus(`Saved prefix pivot: ${p} => (${pivotOverrides[p].x.toFixed(3)}, ${pivotOverrides[p].y.toFixed(3)})`);
    });
  }

  if (btnCopyOverrides){
    btnCopyOverrides.addEventListener('click', async ()=>{
      const txt = JSON.stringify(pivotOverrides, null, 2);
      elOutput.value = txt;
      try{
        await navigator.clipboard.writeText(txt);
        setStatus('Copied overrides JSON');
      }catch(e){
        setStatus('Overrides JSON prepared (clipboard blocked)');
      }
    });
  }

  if (btnSaveLS){
    btnSaveLS.addEventListener('click', ()=>{
      // also store current prefix value right now
      const p = currentPrefix();
      if (p) pivotOverrides[p] = currentPivot();
      const ok = writeOverridesToLS(pivotOverrides);
      setStatus(ok ? 'Saved to localStorage: PO_PIVOT_OVERRIDES' : 'ERR: failed to write localStorage');
    });
  }

  if (btnLoadLS){
    btnLoadLS.addEventListener('click', ()=>{
      pivotOverrides = readOverridesFromLS();
      const p = currentPrefix();
      if (p && pivotOverrides[p]){
        elPivotX.value = pivotOverrides[p].x;
        elPivotY.value = pivotOverrides[p].y;
        setStatus(`Loaded pivot for prefix: ${p}`);
      }else{
        setStatus('Loaded localStorage (no pivot for current prefix)');
      }
      draw();
    });
  }
</script>
</body>
</html>
