<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Pivot Tuner v16 (ingame exact)</title>
<style>
  :root{
    --bg:#0b0f16;
    --panel:#0f1724;
    --panel2:#0b1220;
    --txt:#d7e1ff;
    --muted:#9fb0d9;
    --line:#22304d;
    --accent:#4fe3a0;
    --warn:#ffcc66;
    --err:#ff6b6b;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--txt);font:13px/1.3 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; height:100vh; overflow:hidden;}
  .wrap{display:flex;height:100vh;}
  .left{width:360px;min-width:320px;max-width:460px;background:linear-gradient(180deg,var(--panel),var(--panel2));border-right:1px solid var(--line);overflow:auto;padding:12px;}
  .right{flex:1;position:relative;min-width:0;}
  .row{display:flex;gap:8px;align-items:center;margin:6px 0;}
  .col{display:flex;flex-direction:column;gap:6px;}
  .grid2{display:grid;grid-template-columns:1fr 1fr;gap:8px;}
  .grid3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px;}
  label{color:var(--muted);font-size:12px;}
  input,select,button,textarea{
    width:100%;
    background:#0b1220;
    color:var(--txt);
    border:1px solid #1b2946;
    border-radius:8px;
    padding:8px 10px;
    outline:none;
  }
  input[type="number"]{padding-right:6px}
  button{cursor:pointer;background:#0e1a32;}
  button:hover{border-color:#2a3a66}
  button.primary{background:#112a2a;border-color:#1f6b55}
  button.primary:hover{border-color:#3ee6a6}
  .chips{display:flex;gap:6px;flex-wrap:wrap;margin:6px 0 10px;}
  .chip{padding:6px 8px;border-radius:999px;border:1px solid #22304d;background:#0b1220;color:var(--txt);cursor:pointer;font-size:12px; user-select:none;}
  .chip:hover{border-color:#3ee6a6}
  .status{white-space:pre-wrap;padding:8px 10px;border-radius:10px;border:1px solid #1b2946;background:#0b1220;color:var(--muted);margin-top:8px;}
  .status.err{border-color:#3b1b1b;color:#ffd0d0}
  .status.ok{border-color:#1f6b55;color:#c9ffe9}
  .hint{color:var(--muted);font-size:12px;margin-top:8px}
  textarea{height:76px;resize:vertical;}
  canvas{position:absolute;inset:0;width:100%;height:100%;display:block;}
  .topbar{position:absolute;left:12px;top:10px;display:flex;gap:10px;align-items:center;color:var(--muted);font-size:12px;background:rgba(11,18,32,.55);padding:6px 10px;border:1px solid rgba(34,48,77,.6);border-radius:10px;backdrop-filter:blur(8px); pointer-events:none;}
  .kbd{border:1px solid rgba(34,48,77,.8);border-bottom-color:rgba(34,48,77,.4);padding:1px 6px;border-radius:6px;color:var(--txt);font-size:11px;background:rgba(15,23,36,.35)}
  .check{display:flex;align-items:center;gap:8px;margin:6px 0;}
  .check input{width:auto}
  hr{border:0;border-top:1px solid var(--line);margin:12px 0}
  a{color:#9ee0ff}

  .danger{border-color:rgba(255,107,107,.65); color:#ffd0d0;}
  .chip{display:flex;align-items:center;justify-content:space-between;gap:10px;}
  .chipX{opacity:.75; font-weight:700; padding:0 2px;}
  .chipX:hover{opacity:1; color:var(--err);}
</style>
</head>
<body>
<div class="wrap">
  <div class="left">
    <div style="font-weight:700;font-size:14px;">Pivot Tuner v16</div>
    <div class="hint">
      목표: <b>인게임 buildings.js 수식 그대로</b>로 렌더링해서, 여기서 잡은 <b>pivot 값이 인게임 타일맵과 1:1</b>로 맞게.
      <br/>핵심: JSON은 <b>anchor가 아니라 pivot</b>을 써야 인게임에 먹는다.
    </div>

    <div class="row" style="margin-top:10px;">
      <div class="col" style="flex:1">
        <label>Atlas JSON URL</label>
        <input id="atlasUrl" placeholder="asset/sprite/const/normal/barrack/barrack_idle.json"/>
        <div class="hint" id="resolvedLinks">Resolved URLs will appear here after Load.</div>
      </div>
    </div>

    
    <div class="row" style="margin-top:10px;">
      <div class="col" style="flex:1">
        <label>Path helper (auto)</label>
        <div class="grid3">
          <input id="assetRoot" placeholder="asset/sprite" value="asset/sprite"/>
          <input id="folderHint" placeholder="const/normal/barrack  | unit/tank/harvester"/>
          <button id="btnBuildUrl">Build URL</button>
        </div>
        <div class="hint">- prefix가 있으면: {root}/{folder}/{prefix}.json
- folder 비우고 Build 누르면(건물용): prefix로 const/normal|const_anim|distruct 추측해서 채움</div>
        <div class="grid3" style="margin-top:6px;">
          <input id="presetName" placeholder="Preset name (optional)"/>
          <button id="btnSavePreset">Save preset</button>
          <button id="btnClearPresets" class="danger">Clear</button>
        </div>
        <div class="hint">저장된 프리셋 클릭 = 즉시 로드. × 클릭 = 삭제. (브라우저 localStorage에 저장됨)</div>
        <div class="chips" id="presetChips"></div>
      </div>
    </div>

    <div class="row">
      <button id="btnLoad" class="primary">Load</button>
      <button id="btnReload">Reload</button>
    </div>

    <div id="status" class="status">Ready.</div>

    <hr/>

    <div class="grid2">
      <div class="col">
        <label>Set (prefix)</label>
        <input id="prefix" placeholder="barrack_idle / barrack_con_complete / barrack_distruction"/>
      </div>
      <div class="col">
        <label>Frame</label>
        <select id="frameSel"></select>
      </div>
    </div>

    <div class="grid2">
      <div class="col">
        <label>FPS</label>
        <input id="fps" type="number" step="1" min="1" max="60" value="20"/>
      </div>
      <div class="col">
        <label>BASE_SCALE (game)</label>
        <input id="baseScale" type="number" step="0.01" min="0.02" max="2" value="0.14"/>
      </div>
    </div>

    <div class="row">
      <button id="btnPlay">Play</button>
      <button id="btnPause">Pause</button>
      <button id="btnStep">1 Frame</button>
    </div>

    <label>Pivot X (0..1)</label>
    <div class="grid2">
      <button id="btnXMinus">X-</button>
      <button id="btnXPlus">X+</button>
    </div>
    <input id="pivotX" type="range" min="0" max="1" step="0.0001" value="0.5"/>

    <label>Pivot Y (0..1)</label>
    <div class="grid2">
      <button id="btnYMinus">Y-</button>
      <button id="btnYPlus">Y+</button>
    </div>
    <input id="pivotY" type="range" min="0" max="1" step="0.0001" value="0.5"/>

    <div class="row">
      <button id="btnApplyPrefix" class="primary">Apply pivot to prefix</button>
      <button id="btnDownload">Download patched JSON</button>
    </div>

    <label>Copy/paste (JSON pivot)</label>
    <textarea id="out" readonly></textarea>

    <hr/>

    <div style="font-weight:700;margin-bottom:6px;">Ingame coords (match)</div>

    <div class="grid2">
      <div class="col"><label>TILE (px)</label><input id="tile" type="number" value="110"/></div>
      <div class="col"><label>Cam zoom (game)</label><input id="camZoom" type="number" step="0.01" value="1"/></div>
    </div>

    <div class="grid2">
      <div class="col"><label>Cam worldX (px)</label><input id="camX" type="number" step="1" value="0"/></div>
      <div class="col"><label>Cam worldY (px)</label><input id="camY" type="number" step="1" value="0"/></div>
    </div>

    <div class="grid2">
      <div class="col"><label>Building tileX (origin)</label><input id="btx" type="number" step="1" value="0"/></div>
      <div class="col"><label>Building tileY (origin)</label><input id="bty" type="number" step="1" value="0"/></div>
    </div>

    <div class="grid2">
      <div class="col"><label>Footprint W (tw)</label><input id="tw" type="number" step="1" min="1" value="2"/></div>
      <div class="col"><label>Footprint H (th)</label><input id="th" type="number" step="1" min="1" value="2"/></div>
    </div>

    <div class="grid2">
      <div class="col">
        <label>Anchor mode</label>
        <select id="anchorMode">
          <option value="center">center (ingame default)</option>
          <option value="south">south edge center</option>
          <option value="sw">south-west corner</option>
        </select>
      </div>
      <div class="col">
        <label>BaseOffsetY ratio</label>
        <input id="baseYRatio" type="number" step="0.01" value="0.22"/>
      </div>
    </div>

    <div class="check">
      <input id="useDZ" type="checkbox" checked/>
      <label for="useDZ" style="margin:0">Use DZ (barracks): sy = worldToScreenY - max(tw,th)*ISO_Y*(BASE_SCALE*cam.zoom)</label>
    </div>

    <hr/>

    <div style="font-weight:700;margin:10px 0 6px;">View (pan/zoom)</div>

    <div class="grid2">
      <div class="col"><label>View zoom</label><input id="viewZoom" type="number" step="0.05" value="1"/></div>
      <div class="col"><label>Grid span (tiles)</label><input id="gridSpan" type="number" step="1" min="6" value="30"/></div>
    </div>

    <div class="row">
      <button id="btnResetView">Reset view</button>
      <button id="btnFit">Fit to footprint</button>
    </div>

    <div class="check"><input id="showGrid" type="checkbox" checked/><label for="showGrid" style="margin:0">Grid</label></div>
    <div class="check"><input id="showFoot" type="checkbox" checked/><label for="showFoot" style="margin:0">Footprint (exact)</label></div>
    <div class="check"><input id="showAxis" type="checkbox" checked/><label for="showAxis" style="margin:0">Axis</label></div>
    <div class="check"><input id="showBounds" type="checkbox"/><label for="showBounds" style="margin:0">Frame bbox</label></div>

    <div class="hint">
      조작: <span class="kbd">드래그</span> 팬, <span class="kbd">휠</span> 줌, <span class="kbd">더블클릭</span> Fit.
      <br/>인게임 1:1 확인은 <b>Cam zoom=1</b>, <b>View zoom=1</b>, <b>pan=0</b>에서.
    </div>
  </div>

  <div class="right">
    <div class="topbar" id="topbar">
      <span id="topInfo">canvas</span>
      <span class="kbd">drag</span><span class="kbd">wheel</span><span class="kbd">dblclick</span>
    </div>
    <canvas id="cv"></canvas>
  </div>
</div>

<script>
'use strict';

// ===== helpers
const $ = (id)=>document.getElementById(id);
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const num = (id, fallback)=>{
  const el=$(id);
  const v = el? parseFloat(el.value): NaN;
  return Number.isFinite(v) ? v : fallback;
};


// ===== state
let atlasData=null;
let textures=[]; // [{img,name}]
let frames=[];   // unified [{name, tex, rect, sss, source, pivot, rawRef}]
let playing=false;
let lastT=0;

const cv=$('cv');
const ctx=cv.getContext('2d', {alpha:true});
let dpr=1;

// view pan/zoom (screen space)
let panX=0, panY=0;
let isPanning=false;
let panStart=null;

// ===== canvas resize (robust)
function resizeCanvas(){
  const r=cv.getBoundingClientRect();
  dpr=window.devicePixelRatio||1;
  cv.width=Math.max(1,Math.floor(r.width*dpr));
  cv.height=Math.max(1,Math.floor(r.height*dpr));
}
const ro = new ResizeObserver(()=>{ resizeCanvas(); });
ro.observe(document.querySelector('.right'));
window.addEventListener('resize', resizeCanvas);
setTimeout(resizeCanvas, 0);

// ===== status
function setStatus(msg, kind=''){
  const el=$('status');
  el.textContent=msg;
  el.className='status' + (kind?(' '+kind):'');
}

// ===== atlas parsing (TexturePacker JSON: single or textures[])
function parseTP(json){
  let texList=[];
  if(Array.isArray(json.textures)){
    texList=json.textures.map(t=>({image:t.image, frames:t.frames||{}}));
  }else{
    const img = json.meta?.image || json.image || json.meta?.imageName || 'atlas.png';
    let framesObj = json.frames;
    if(Array.isArray(framesObj)){
      const obj={};
      for(const f of framesObj){
        if(!f.filename) continue;
        obj[f.filename]=f;
      }
      framesObj=obj;
    }
    texList=[{image: img, frames: framesObj||{}}];
  }

  const unified=[];
  for(let ti=0; ti<texList.length; ti++){
    const fr=texList[ti].frames||{};
    for(const [name, data] of Object.entries(fr)){
      const frame=data.frame || data; // {x,y,w,h}
      const w = frame.w ?? frame.width ?? 0;
      const h = frame.h ?? frame.height ?? 0;

      const sss = data.spriteSourceSize || data.spriteSourceSize || {x:0,y:0,w, h};
      const src = data.sourceSize || {w: (sss.w ?? sss.width ?? w), h: (sss.h ?? sss.height ?? h)};

      // IMPORTANT: game uses fr.pivot (not anchor). We still read anchor if pivot missing.
      const pv = data.pivot || data.anchor || {x:0.5,y:0.5};

      unified.push({
        name,
        tex: ti,
        rect:{x:frame.x||0, y:frame.y||0, w, h},
        sss:{x:sss.x||0, y:sss.y||0, w:(sss.w??sss.width??w), h:(sss.h??sss.height??h)},
        source:{w:(src.w??src.width??w), h:(src.h??src.height??h)},
        pivot:{x: clamp(pv.x ?? 0.5, 0, 1), y: clamp(pv.y ?? 0.5, 0, 1)},
        rawRef: data
      });
    }
  }

  // sort by trailing number if any
  unified.sort((a,b)=>{
    const na=a.name.match(/(\d+)(?=\D*$)/);
    const nb=b.name.match(/(\d+)(?=\D*$)/);
    if(na && nb) return (parseInt(na[1],10)-parseInt(nb[1],10)) || a.name.localeCompare(b.name);
    if(na && !nb) return -1;
    if(!na && nb) return 1;
    return a.name.localeCompare(b.name);
  });

  return {texList, unified};
}

async function fetchJson(url){
  const res = await fetch(url, {cache:'no-store'});
  const text = await res.text();
  if(!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);
  const t = text.trim();
  if(t.startsWith('<!doctype') || t.startsWith('<html') || t.includes('<head>')){
    throw new Error('Atlas URL returned HTML (404/fallback 의심)');
  }
  try{ return JSON.parse(text); }
  catch(e){ throw new Error('JSON parse fail: ' + e.message); }
}

async function loadAtlas(){
  try{
    setStatus('Loading atlas JSON...');
    const input=$('atlasUrl').value.trim();
    if(!input){ setStatus('ERR: atlasUrl empty','err'); return; }

    const atlasUrl = new URL(input, location.href).toString();
    $('resolvedLinks').innerHTML =
      `Atlas: <a href="${atlasUrl}" target="_blank" rel="noopener">open</a><br><span style="opacity:.9">${atlasUrl}</span>`;

    atlasData = await fetchJson(atlasUrl);
    const parsed = parseTP(atlasData);

    // load textures
    textures=[];
    for(const t of parsed.texList){
      const imgUrl = new URL(t.image, atlasUrl).toString();
      const img = new Image();
      const p = new Promise((resolve,reject)=>{
        img.onload=()=>resolve();
        img.onerror=()=>reject(new Error('image load fail: ' + t.image));
      });
      img.src = imgUrl;
      await p;
      textures.push({img, name:t.image, url:imgUrl});
    }

    const texLinks = textures.map(t => `Texture: <a href="${t.url}" target="_blank" rel="noopener">open</a><br><span style="opacity:.9">${t.url}</span>`).join('<br>');
    $('resolvedLinks').innerHTML += '<br>' + texLinks;

    frames = parsed.unified;

    if(!$('prefix').value.trim() && frames.length){
      const f0=frames[0].name;
      const m=f0.match(/^(.*?)(\d+)?\.png$/i);
      $('prefix').value = m ? m[1] : f0.replace(/\.png$/i,'');
    }

    rebuildFrameSelect();
    syncPivotFromFrame();
    updateOutput();
    setStatus(`Loaded: ${frames.length} frames, ${textures.length} texture(s).`,'ok');
  try{ rememberPaths(); }catch(e){}
  }catch(e){
    setStatus('Load failed: ' + e.message,'err');
    console.error(e);
  }
}

function rebuildFrameSelect(){
  const prefix=$('prefix').value.trim();
  const sel=$('frameSel');
  sel.innerHTML='';
  const list = frames.filter(f=>!prefix || f.name.startsWith(prefix));
  const use = list.length ? list : frames;
  for(const f of use){
    const opt=document.createElement('option');
    opt.value=f.name; opt.textContent=f.name;
    sel.appendChild(opt);
  }
  if(sel.options.length) sel.selectedIndex=0;
}

function getCurrentFrame(){
  const name=$('frameSel').value;
  if(!name) return frames[0]||null;
  return frames.find(f=>f.name===name) || frames[0] || null;
}

function syncPivotFromFrame(){
  const f=getCurrentFrame();
  if(!f) return;
  $('pivotX').value = clamp(f.pivot?.x ?? 0.5, 0, 1);
  $('pivotY').value = clamp(f.pivot?.y ?? 0.5, 0, 1);
  updateOutput();
}

function updateOutput(){
  const x=+($('pivotX').value||0.5);
  const y=+($('pivotY').value||0.5);
  $('out').value = JSON.stringify({x:+x.toFixed(4), y:+y.toFixed(4)});
}

// ===== ingame math (matches game.js + buildings.js)
function isoParams(){
  const TILE=+($('tile').value||110);
  return {TILE, ISO_X:TILE/2, ISO_Y:TILE/4};
}
function worldToIso(wx, wy){
  const {TILE, ISO_X, ISO_Y} = isoParams();
  return { x: (wx - wy) * (ISO_X / TILE), y: (wx + wy) * (ISO_Y / TILE) };
}
// relative screen coords WITHOUT baseOffset (baseOffset applied in render transform)
function worldToScreenRel(wx, wy, cam){
  const iso = worldToIso(wx, wy);
  const camIso = worldToIso(cam.x, cam.y);
  return { x: (iso.x - camIso.x) * cam.zoom, y: (iso.y - camIso.y) * cam.zoom };
}
function getCam(){
  return { x:+($('camX').value||0), y:+($('camY').value||0), zoom:+($('camZoom').value||1) };
}
function baseOffset(){
  const w=cv.width/dpr, h=cv.height/dpr;
  return {baseX:w*0.5, baseY:h*(+($('baseYRatio').value||0.22))};
}
function buildingWorldFromTileOrigin(tx,ty,tw,th){
  const {TILE}=isoParams();
  const w=tw*TILE, h=th*TILE;
  return { cx:(tx*TILE + w/2), cy:(ty*TILE + h/2), w, h };
}
function anchorWorldFromTileOrigin(tx,ty,tw,th,mode){
  const {TILE}=isoParams();
  if(mode==='center'){
    const b=buildingWorldFromTileOrigin(tx,ty,tw,th);
    return {wx:b.cx, wy:b.cy};
  }
  if(mode==='south'){
    // bottom edge center of footprint boundary
    return {wx:(tx + tw/2)*TILE, wy:(ty + th)*TILE};
  }
  // south-west corner boundary
  return {wx:(tx)*TILE, wy:(ty + th)*TILE};
}

// ===== drawing helpers
function clear(){
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,cv.width,cv.height);
}
function drawArrow(a,b,label,off){
  ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
  const ang=Math.atan2(b.y-a.y,b.x-a.x);
  const hl=10;
  ctx.beginPath();
  ctx.moveTo(b.x,b.y);
  ctx.lineTo(b.x - hl*Math.cos(ang-0.5), b.y - hl*Math.sin(ang-0.5));
  ctx.lineTo(b.x - hl*Math.cos(ang+0.5), b.y - hl*Math.sin(ang+0.5));
  ctx.closePath();
  ctx.fillStyle='rgba(140,190,255,0.85)';
  ctx.fill();
  ctx.fillStyle='rgba(200,225,255,0.9)';
  ctx.font='12px system-ui, sans-serif';
  ctx.fillText(label, b.x + off*Math.cos(ang+Math.PI/2), b.y + off*Math.sin(ang+Math.PI/2));
}

function drawGrid(cam, view){
  if(!$('showGrid').checked) return;
  const {TILE, ISO_X, ISO_Y} = isoParams();
  const span = clamp(+$('gridSpan').value||30, 6, 200);
  const tx0 = +($('btx').value||0);
  const ty0 = +($('bty').value||0);

  ctx.save();
  ctx.scale(dpr,dpr);
  const {baseX, baseY}=baseOffset();
  ctx.translate(baseX + view.panX, baseY + view.panY);
  ctx.scale(view.zoom, view.zoom);

  ctx.lineWidth = 1;
  ctx.strokeStyle = 'rgba(74,120,170,0.18)';

  const halfX = ISO_X * cam.zoom;
  const halfY = ISO_Y * cam.zoom;

  const startX = tx0 - span, endX = tx0 + span;
  const startY = ty0 - span, endY = ty0 + span;
  const step = span>60 ? 2 : 1;

  for(let ty=startY; ty<=endY; ty+=step){
    for(let tx=startX; tx<=endX; tx+=step){
      const p = worldToScreenRel((tx+0.5)*TILE, (ty+0.5)*TILE, cam);
      ctx.beginPath();
      ctx.moveTo(p.x, p.y - halfY);
      ctx.lineTo(p.x + halfX, p.y);
      ctx.lineTo(p.x, p.y + halfY);
      ctx.lineTo(p.x - halfX, p.y);
      ctx.closePath();
      ctx.stroke();
    }
  }

  ctx.restore();
}

function drawFootprintExact(cam, view){
  if(!$('showFoot').checked) return;
  const {TILE, ISO_X, ISO_Y} = isoParams();
  const tw = Math.max(1, parseInt($('tw').value||2,10));
  const th = Math.max(1, parseInt($('th').value||2,10));
  const tx0 = parseInt($('btx').value||0,10);
  const ty0 = parseInt($('bty').value||0,10);

  const halfX = ISO_X * cam.zoom;
  const halfY = ISO_Y * cam.zoom;

  const pTop    = worldToScreenRel((tx0+0.5)*TILE, (ty0+0.5)*TILE, cam);
  const pRight  = worldToScreenRel((tx0+tw-1+0.5)*TILE, (ty0+0.5)*TILE, cam);
  const pBottom = worldToScreenRel((tx0+tw-1+0.5)*TILE, (ty0+th-1+0.5)*TILE, cam);
  const pLeft   = worldToScreenRel((tx0+0.5)*TILE, (ty0+th-1+0.5)*TILE, cam);

  const V0 = {x:pTop.x,    y:pTop.y - halfY};
  const V1 = {x:pRight.x + halfX, y:pRight.y};
  const V2 = {x:pBottom.x, y:pBottom.y + halfY};
  const V3 = {x:pLeft.x - halfX, y:pLeft.y};

  ctx.save();
  ctx.scale(dpr,dpr);
  const {baseX, baseY}=baseOffset();
  ctx.translate(baseX + view.panX, baseY + view.panY);
  ctx.scale(view.zoom, view.zoom);

  ctx.lineWidth = 2;
  ctx.strokeStyle = 'rgba(79,227,160,0.95)';
  ctx.fillStyle = 'rgba(79,227,160,0.08)';
  ctx.beginPath();
  ctx.moveTo(V0.x, V0.y);
  ctx.lineTo(V1.x, V1.y);
  ctx.lineTo(V2.x, V2.y);
  ctx.lineTo(V3.x, V3.y);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  // internal splits
  ctx.lineWidth = 2;
  ctx.strokeStyle = 'rgba(79,227,160,0.75)';
  for(let i=1;i<tw;i++){
    const t=i/tw;
    const A={x:V0.x+(V1.x-V0.x)*t, y:V0.y+(V1.y-V0.y)*t};
    const B={x:V3.x+(V2.x-V3.x)*t, y:V3.y+(V2.y-V3.y)*t};
    ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();
  }
  for(let j=1;j<th;j++){
    const t=j/th;
    const A={x:V0.x+(V3.x-V0.x)*t, y:V0.y+(V3.y-V0.y)*t};
    const B={x:V1.x+(V2.x-V1.x)*t, y:V1.y+(V2.y-V1.y)*t};
    ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();
  }

  if($('showAxis').checked){
    ctx.lineWidth=3;
    const origin={x:V0.x,y:V0.y};
    const wEnd={x:V1.x,y:V1.y};
    const hEnd={x:V3.x,y:V3.y};
    ctx.strokeStyle='rgba(140,190,255,0.85)';
    drawArrow(origin,wEnd,'W='+tw+' ↘(+x)',10);
    drawArrow(origin,hEnd,'H='+th+' ↙(+y)',10);
  }

  ctx.restore();
}

function drawSprite(cam, view){
  const f=getCurrentFrame();
  if(!f) return;
  if(!atlasData || !textures.length) return;

  const img = textures[f.tex]?.img;
  if(!img) return;

  const tx0 = parseInt($('btx').value||0,10);
  const ty0 = parseInt($('bty').value||0,10);
  const tw = Math.max(1, parseInt($('tw').value||2,10));
  const th = Math.max(1, parseInt($('th').value||2,10));
  const mode = $('anchorMode').value;

  const anchor = anchorWorldFromTileOrigin(tx0,ty0,tw,th,mode);
  const p = worldToScreenRel(anchor.wx, anchor.wy, cam);

  const {ISO_Y} = isoParams();
  const useDZ = $('useDZ').checked;
  const baseScaleNum = (()=>{ const v=parseFloat($("baseScale").value); return Number.isFinite(v) && v>0 ? v : 0.22; })();
  let dz = useDZ ? (Math.max(tw,th) * ISO_Y * (baseScaleNum * cam.zoom)) : 0;
  if (!Number.isFinite(dz)) dz = 0;

  const scale = baseScaleNum * cam.zoom;

  const pvx = (+$('pivotX').value||0.5);
  const pvy = (+$('pivotY').value||0.5);

  const frame = f.rect;
  const sss   = f.sss;
  const src   = f.source;

  const sx = p.x;
  const sy = p.y - dz;

  // EXACT match to buildings.js drawFrameTeam:
  const dx = sx - (pvx * src.w - sss.x) * scale;
  const dy = sy - (pvy * src.h - sss.y) * scale;
  // Guard against NaN/Infinity so sprite never silently disappears
  const dxF = Number.isFinite(dx) ? dx : 0;
  const dyF = Number.isFinite(dy) ? dy : 0;
  const dw = frame.w * scale;
  const dh = frame.h * scale;

  ctx.save();
  ctx.scale(dpr,dpr);
  const {baseX, baseY}=baseOffset();
  ctx.translate(baseX + view.panX, baseY + view.panY);
  ctx.scale(view.zoom, view.zoom);

  ctx.imageSmoothingEnabled=true;
  ctx.drawImage(img, frame.x, frame.y, frame.w, frame.h, dx, dy, dw, dh);

  if($('showBounds').checked){
    ctx.strokeStyle='rgba(255,200,80,0.9)';
    ctx.lineWidth=2;
    ctx.strokeRect(dx,dy,dw,dh);
  }
  ctx.restore();

  $('topInfo').textContent =
    `frame: ${f.name} | baseScale=${baseScaleNum.toFixed(3)} | view=${state.viewZoom.toFixed(2)} | dz=${dz.toFixed(1)} | draw=(${dxF.toFixed(1)},${dyF.toFixed(1)})`;
}

// ===== loop
function tick(t){
  requestAnimationFrame(tick);
  if(!cv.width || !cv.height) return;

  const cam=getCam();
  const view={zoom:+($('viewZoom').value||1), panX, panY};

  // animation advance
  if(playing && frames.length){
    const fps=clamp(+($('fps').value||20),1,60);
    if(!lastT) lastT=t;
    const dt=t-lastT;
    const step=1000/fps;
    if(dt>=step){
      lastT=t-(dt%step);
      const prefix=$('prefix').value.trim();
      const list = frames.filter(fr=>!prefix || fr.name.startsWith(prefix));
      const use=list.length?list:frames;
      const curName=$('frameSel').value;
      let idx=use.findIndex(fr=>fr.name===curName);
      idx = (idx<0?0:idx);
      const next=use[(idx+1)%use.length];
      $('frameSel').value=next.name;
    }
  }else{
    lastT=0;
  }

  clear();
  drawGrid(cam, view);
  drawFootprintExact(cam, view);

  if(!atlasData || !frames.length){
    ctx.save(); ctx.scale(dpr,dpr);
    ctx.fillStyle='rgba(255,255,255,0.85)'; ctx.font='14px system-ui, sans-serif';
    ctx.fillText('No atlas loaded. Set Atlas JSON URL and press Load.', 18, 28);
    ctx.restore();
    return;
  }
  if(!textures.length){
    ctx.save(); ctx.scale(dpr,dpr);
    ctx.fillStyle='rgba(255,150,150,0.9)'; ctx.font='14px system-ui, sans-serif';
    ctx.fillText('Atlas JSON loaded, but texture image failed. Check meta.image path.', 18, 28);
    ctx.restore();
    return;
  }

  drawSprite(cam, view);
}

// ===== view controls
function resetView(){
  panX=0; panY=0;
  $('viewZoom').value=1;
}
function fitToFootprint(){
  const cam=getCam();
  const {TILE, ISO_X, ISO_Y} = isoParams();
  const tw=Math.max(1, parseInt($('tw').value||2,10));
  const th=Math.max(1, parseInt($('th').value||2,10));
  const tx0=parseInt($('btx').value||0,10);
  const ty0=parseInt($('bty').value||0,10);

  const halfX=ISO_X*cam.zoom, halfY=ISO_Y*cam.zoom;

  const pTop    = worldToScreenRel((tx0+0.5)*TILE, (ty0+0.5)*TILE, cam);
  const pRight  = worldToScreenRel((tx0+tw-1+0.5)*TILE, (ty0+0.5)*TILE, cam);
  const pBottom = worldToScreenRel((tx0+tw-1+0.5)*TILE, (ty0+th-1+0.5)*TILE, cam);
  const pLeft   = worldToScreenRel((tx0+0.5)*TILE, (ty0+th-1+0.5)*TILE, cam);

  const V0={x:pTop.x, y:pTop.y-halfY};
  const V1={x:pRight.x+halfX, y:pRight.y};
  const V2={x:pBottom.x, y:pBottom.y+halfY};
  const V3={x:pLeft.x-halfX, y:pLeft.y};

  const xs=[V0.x,V1.x,V2.x,V3.x], ys=[V0.y,V1.y,V2.y,V3.y];
  const minX=Math.min(...xs), maxX=Math.max(...xs);
  const minY=Math.min(...ys), maxY=Math.max(...ys);
  const bw=maxX-minX, bh=maxY-minY;

  const w=cv.width/dpr, h=cv.height/dpr;
  const pad=60;
  const zx=(w-pad)/Math.max(1,bw);
  const zy=(h-pad)/Math.max(1,bh);
  const z=clamp(Math.min(zx,zy), 0.2, 6);
  $('viewZoom').value=+z.toFixed(2);

  const cx=(minX+maxX)/2, cy=(minY+maxY)/2;
  panX=-cx; panY=-cy;
}

// mouse interactions
cv.addEventListener('mousedown',(e)=>{
  isPanning=true;
  panStart={x:e.clientX, y:e.clientY, px:panX, py:panY};
});
window.addEventListener('mouseup',()=>{ isPanning=false; panStart=null; });
window.addEventListener('mousemove',(e)=>{
  if(!isPanning||!panStart) return;
  panX = panStart.px + (e.clientX-panStart.x);
  panY = panStart.py + (e.clientY-panStart.y);
});
cv.addEventListener('wheel',(e)=>{
  e.preventDefault();
  const z=+($('viewZoom').value||1);
  const delta=Math.sign(e.deltaY);
  const next=clamp(z*(delta>0?0.9:1.1), 0.1, 20);
  $('viewZoom').value=+next.toFixed(2);
},{passive:false});
cv.addEventListener('dblclick', ()=>fitToFootprint());

// ===== apply & download
function applyToPrefix(){
  const prefix=$('prefix').value.trim();
  if(!prefix){ setStatus('ERR: prefix empty','err'); return; }
  if(!atlasData){ setStatus('ERR: no atlas loaded','err'); return; }

  const x=+($('pivotX').value||0.5);
  const y=+($('pivotY').value||0.5);

  let n=0;
  for(const f of frames){
    if(f.name.startsWith(prefix)){
      f.pivot={x,y};
      if(f.rawRef){
        // write pivot (and also keep anchor in sync if the json used anchor earlier)
        f.rawRef.pivot={x,y};
        if(f.rawRef.anchor) f.rawRef.anchor={x,y};
      }
      n++;
    }
  }
  setStatus(`Applied pivot {x:${x.toFixed(4)}, y:${y.toFixed(4)}} to ${n} frame(s) with prefix "${prefix}".`,'ok');
}

function downloadPatched(){
  if(!atlasData){ setStatus('ERR: no atlas loaded','err'); return; }
  const blob = new Blob([JSON.stringify(atlasData, null, 2)], {type:'application/json'});
  const a=document.createElement('a');
  a.href=URL.createObjectURL(blob);
  const name = ( $('prefix').value.trim() || 'atlas' ) + '_patched.json';
  a.download=name;
  a.click();
  URL.revokeObjectURL(a.href);
  setStatus('Downloaded: ' + name,'ok');
}

// ===== wiring
$('btnLoad').addEventListener('click', loadAtlas);
$('btnReload').addEventListener('click', loadAtlas);

// ===== presets (v18)
const LS_KEY = 'pivot_tuner_v18';
function loadLS(){
  try{ return JSON.parse(localStorage.getItem(LS_KEY) || '{}'); }catch(e){ return {}; }
}
function saveLS(obj){ localStorage.setItem(LS_KEY, JSON.stringify(obj)); }

function normJoin(...parts){
  return parts
    .filter(Boolean)
    .map(s=>String(s).trim().replace(/(^\/+|\/+$)/g,''))
    .filter(s=>s.length)
    .join('/');
}
function guessFolderFromPrefix(prefix){
  const p = (prefix||'').toLowerCase();
  const base = (prefix||'').split('_')[0] || 'atlas';
  if (p.includes('distruct') || p.includes('destruct') || p.includes('destroy')) return `const/distruct/${base}`;
  if (p.includes('const') || p.includes('con_') || p.includes('build') || p.includes('complete')) return `const/const_anim/${base}`;
  if (p.includes('idle')) return `const/normal/${base}`;
  return `const/normal/${base}`;
}

let LS = loadLS();
$('assetRoot').value = LS.assetRoot || 'asset/sprite';
$('folderHint').value = LS.folderHint || '';
$('presetName').value = '';

function getPresets(){
  const arr = Array.isArray(LS.presets) ? LS.presets : [];
  return arr.slice(0, 64);
}
function setPresets(arr){
  LS.presets = arr.slice(0, 64);
  saveLS(LS);
}
function renderPresets(){
  const box = $('presetChips');
  box.innerHTML = '';
  const presets = getPresets();
  // default presets (only if empty)
  if (presets.length === 0){
    setPresets([
      {name:'barrack idle', url:'asset/sprite/const/normal/barrack/barrack_idle.json', prefix:'barrack_idle'},
      {name:'barrack const', url:'asset/sprite/const/const_anim/barrack/barrack_const.json', prefix:'barrack_con_complete'},
      {name:'barrack dist', url:'asset/sprite/const/distruct/barrack/barrack_distruct.json', prefix:'barrack_distruction'},
    ]);
    LS = loadLS();
  }
  for (let i=0;i<getPresets().length;i++){
    const pr = getPresets()[i];
    const d = document.createElement('div');
    d.className='chip';
    d.dataset.i = String(i);
    const s1=document.createElement('span');
    s1.textContent = (pr.name||pr.prefix||'preset');
    const s2=document.createElement('span');
    s2.className='chipX';
    s2.title='delete';
    s2.textContent='×';
    d.appendChild(s1);
    d.appendChild(s2);
    box.appendChild(d);
  }
}
$('presetChips').addEventListener('click', (ev)=>{
  const chip = ev.target.closest('.chip');
  if(!chip) return;
  const i = Number(chip.dataset.i);
  const presets = getPresets();
  if(!Number.isFinite(i) || !presets[i]) return;

  if(ev.target.classList.contains('chipX')){
    presets.splice(i,1);
    setPresets(presets);
    LS = loadLS();
    renderPresets();
    setStatus('Preset deleted','ok');
    return;
  }
  const pr = presets[i];
  $('atlasUrl').value = pr.url || '';
  $('prefix').value = pr.prefix || '';
  // remember map
  rememberPaths();
  loadAtlas();
});

function rememberPaths(){
  LS.assetRoot = $('assetRoot').value.trim() || 'asset/sprite';
  LS.folderHint = $('folderHint').value.trim();
  // prefix -> url map
  LS.map = LS.map || {};
  const p = $('prefix').value.trim();
  const u = $('atlasUrl').value.trim();
  if(p && u) LS.map[p] = u;
  saveLS(LS);
}

function tryAutofillUrlFromPrefix(){
  const p = $('prefix').value.trim();
  if(!p) return;
  LS = loadLS();
  const map = LS.map || {};
  if(map[p]){
    $('atlasUrl').value = map[p];
    return;
  }
  // if url empty, build from template
  if(!$('atlasUrl').value.trim()){
    const root = ($('assetRoot').value.trim() || 'asset/sprite');
    let folder = $('folderHint').value.trim();
    if(!folder) folder = guessFolderFromPrefix(p);
    $('folderHint').value = folder;
    $('atlasUrl').value = normJoin(root, folder, `${p}.json`);
  }
}

$('btnBuildUrl').addEventListener('click', ()=>{
  const p = $('prefix').value.trim();
  if(!p){ setStatus('prefix 먼저 입력해','err'); return; }
  const root = ($('assetRoot').value.trim() || 'asset/sprite');
  let folder = $('folderHint').value.trim();
  if(!folder){
    folder = guessFolderFromPrefix(p);
    $('folderHint').value = folder;
  }
  $('atlasUrl').value = normJoin(root, folder, `${p}.json`);
  rememberPaths();
  setStatus('Built URL','ok');
});

$('btnSavePreset').addEventListener('click', ()=>{
  const p = $('prefix').value.trim();
  const u = $('atlasUrl').value.trim();
  if(!p || !u){ setStatus('prefix/url 둘 다 필요','err'); return; }
  const name = ($('presetName').value.trim() || p);
  const presets = getPresets();
  // upsert by name
  const idx = presets.findIndex(x=> (x.name||'') === name);
  const item = {name, url:u, prefix:p};
  if(idx>=0) presets[idx]=item; else presets.unshift(item);
  setPresets(presets);
  LS = loadLS();
  rememberPaths();
  renderPresets();
  setStatus('Saved preset: ' + name,'ok');
});

$('btnClearPresets').addEventListener('click', ()=>{
  if(!confirm('프리셋 전부 삭제?')) return;
  LS = loadLS();
  LS.presets = [];
  LS.map = {};
  saveLS(LS);
  renderPresets();
  setStatus('Cleared presets','ok');
});

$('prefix').addEventListener('input', ()=>{
  // lightweight autofill
  tryAutofillUrlFromPrefix();
});
renderPresets();

// query param support: ?atlas=...&prefix=...
try{
  const qp = new URLSearchParams(location.search);
  const qAtlas = qp.get('atlas');
  const qPrefix = qp.get('prefix');
  if(qAtlas) $('atlasUrl').value = qAtlas;
  if(qPrefix) $('prefix').value = qPrefix;
  if(qAtlas || qPrefix){
    tryAutofillUrlFromPrefix();
  }
}catch(e){}

$('prefix').addEventListener('change', ()=>{ rebuildFrameSelect(); syncPivotFromFrame(); });
$('frameSel').addEventListener('change', ()=>{ playing=false; lastT=0; syncPivotFromFrame(); });

$('btnPlay').addEventListener('click', ()=>{ playing=true; });
$('btnPause').addEventListener('click', ()=>{ playing=false; });
$('btnStep').addEventListener('click', ()=>{
  playing=false;
  const prefix=$('prefix').value.trim();
  const list = frames.filter(fr=>!prefix || fr.name.startsWith(prefix));
  const use=list.length?list:frames;
  if(!use.length) return;
  const curName=$('frameSel').value;
  let idx=use.findIndex(fr=>fr.name===curName);
  idx=(idx<0?0:idx);
  const next=use[(idx+1)%use.length];
  $('frameSel').value=next.name;
});

function nudgePivot(dx,dy){
  const x=clamp(+( $('pivotX').value ) + dx, 0, 1);
  const y=clamp(+( $('pivotY').value ) + dy, 0, 1);
  $('pivotX').value=x; $('pivotY').value=y;
  updateOutput();
}
$('btnXMinus').addEventListener('click', ()=>nudgePivot(-0.001,0));
$('btnXPlus').addEventListener('click', ()=>nudgePivot(0.001,0));
$('btnYMinus').addEventListener('click', ()=>nudgePivot(0,-0.001));
$('btnYPlus').addEventListener('click', ()=>nudgePivot(0,0.001));

$('pivotX').addEventListener('input', updateOutput);
$('pivotY').addEventListener('input', updateOutput);

$('btnApplyPrefix').addEventListener('click', applyToPrefix);
$('btnDownload').addEventListener('click', downloadPatched);

$('btnResetView').addEventListener('click', resetView);
$('btnFit').addEventListener('click', fitToFootprint);

requestAnimationFrame(tick);
updateOutput();
</script>
</body>
</html>
