<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Barrack Pivot Tuner v2 (match game placement)</title>
  <style>
    :root{color-scheme:dark;}
    body{margin:0;display:flex;height:100vh;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    #left{width:380px;min-width:320px;max-width:460px;overflow:auto;padding:14px 14px 18px;background:#0c111a;border-right:1px solid #1f2a3a;}
    #right{flex:1;position:relative;background:radial-gradient(ellipse at center,#101a2a 0%,#070b12 70%);}
    h1{font-size:18px;margin:0 0 10px;}
    .hint{opacity:.82;font-size:12px;line-height:1.45;margin:0 0 14px;}
    .pill{display:inline-block;padding:2px 6px;border:1px solid #2b3d5d;border-radius:999px;font-size:11px;opacity:.9}
    label{display:block;font-size:12px;opacity:.86;margin:10px 0 6px;}
    input,button,textarea,select{width:100%;box-sizing:border-box;border:1px solid #243247;background:#0f1624;color:#e6eefc;border-radius:10px;padding:10px 10px;font-size:14px;}
    input,select{height:38px;}
    textarea{min-height:140px;resize:vertical;line-height:1.35;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:12px;}
    button{cursor:pointer;background:#0f1b33;border-color:#2b3d5d;}
    button:hover{filter:brightness(1.12);}
    .row{display:flex;gap:8px;align-items:center;}
    .row>div{flex:1;}
    .small{height:36px;padding:8px 10px;font-size:13px;}
    .status{white-space:pre-wrap;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:12px;opacity:.9;margin-top:10px;padding:10px;border:1px dashed #2b3d5d;border-radius:10px;}
    .group{border:1px solid #1f2a3a;border-radius:12px;padding:10px;margin-top:10px;background:#0b1424;}
    .groupTitle{font-size:12px;opacity:.9;margin:0 0 6px;}
    .checkRow{display:flex;align-items:center;gap:10px;}
    .checkRow input{width:auto;height:auto;}
    .mini{font-size:11px;opacity:.75;margin:4px 0 0;}
    canvas{width:100%;height:100%;display:block;}
  </style>
</head>
<body>
  <aside id="left">
    <h1>Pivot Tuner v2 ğŸ› ï¸</h1>
    <p class="hint">
      ëª©ì : <b>atlas_tp.jsì˜ drawFrame í”¼ë²— ê³„ì‚°</b>ê³¼ <b>game.jsì˜ isometric ì¢Œí‘œ</b>ë¥¼ ê·¸ëŒ€ë¡œ ë”°ë¼ê°€ì„œ, ì—¬ê¸°ì„œ ë§ì¶˜ í”¼ë²—ì´ ê²Œì„ì—ì„œë„ 1:1ë¡œ ë§ê²Œ ë³´ê¸°.<br/>
      - Atlas JSON ì•ˆ <span class="pill">textures[]</span> multipack ì „ë¶€ ë¡œë“œ.<br/>
      - í”„ë ˆì„ ì •ë ¬: íŒŒì¼ëª… ë ìˆ«ì(ì˜ˆ: barrack_idle12.png).<br/>
      - <b>Apply</b>ëŠ” ë©”ëª¨ë¦¬ì˜ atlasDataë¥¼ ìˆ˜ì •, <b>Download</b>ë¡œ íŒ¨ì¹˜ë³¸ JSON ì €ì¥.
    </p>

    <label>Atlas JSON URL</label>
    <input id="atlasUrl" value="/asset/sprite/const/distruct/barrack/barrack_distruct.json"/>

    <label>Frame prefix (ì˜ˆ: barrack_distruction_ / barrack_con_complete_ / barrack_idle)</label>
    <input id="prefix" value="barrack_distruction_"/>

    <div class="row">
      <div>
        <label>FPS</label>
        <input id="fps" type="number" value="20" min="1" max="120"/>
      </div>
      <div>
        <label>Scale (ê²Œì„ê³¼ ë§ì¶”ëŠ” ê°’)</label>
        <input id="scale" type="number" value="0.14" step="0.01"/>
      </div>
    </div>

    <div class="row">
      <div>
        <label>Pivot X (0~1)</label>
        <input id="pivotX" type="range" min="0" max="1" step="0.0005" value="0.5"/>
      </div>
      <div>
        <label>Pivot Y (0~1)</label>
        <input id="pivotY" type="range" min="0" max="1" step="0.0005" value="0.5"/>
      </div>
    </div>

    <div class="row">
      <button id="btnLoad" class="small">Load</button>
      <button id="btnPlay" class="small">Play</button>
      <button id="btnPrev" class="small">â—€</button>
      <button id="btnNext" class="small">â–¶</button>
    </div>

    <div class="row" style="margin-top:8px">
      <button id="btnApplyCur" class="small">Apply to current</button>
      <button id="btnApplyAll" class="small">Apply to all</button>
    </div>

    <div class="row" style="margin-top:8px">
      <button id="btnDownload" class="small">Download patched JSON</button>
      <button id="btnCopyJS" class="small">Copy JS override</button>
    </div>

    <div class="group">
      <div class="groupTitle">ê²Œì„ ì¢Œí‘œ ëª¨ë“œ (isometric 1:1)</div>
      <div class="checkRow">
        <input id="useGame" type="checkbox" checked/>
        <div style="font-size:13px;opacity:.92">ê²Œì„ ë°°ì¹˜ ë°©ì‹ìœ¼ë¡œ ì˜¤ë²„ë ˆì´/ì•µì»¤ ê³„ì‚°</div>
      </div>
      <div class="mini">game.js ê¸°ì¤€: TILE=128ì´ë©´ ISO_X=64, ISO_Y=32 (ë‹¤ì´ì•„ 128x64)</div>

      <div class="row" style="margin-top:8px">
        <div>
          <label>TILE</label>
          <input id="TILE" type="number" value="128" step="1"/>
        </div>
        <div>
          <label>Cam zoom</label>
          <input id="camZoom" type="number" value="1" step="0.1"/>
        </div>
      </div>

      <div class="row">
        <div>
          <label>Cam tileX</label>
          <input id="camTX" type="number" value="0" step="0.25"/>
        </div>
        <div>
          <label>Cam tileY</label>
          <input id="camTY" type="number" value="0" step="0.25"/>
        </div>
      </div>

      <div class="row">
        <div>
          <label>Building tx</label>
          <input id="bTX" type="number" value="0" step="1"/>
        </div>
        <div>
          <label>Building ty</label>
          <input id="bTY" type="number" value="0" step="1"/>
        </div>
      </div>

      <div class="row">
        <div>
          <label>Footprint W (tw)</label>
          <input id="bTW" type="number" value="3" step="1" min="1"/>
        </div>
        <div>
          <label>Footprint H (th)</label>
          <input id="bTH" type="number" value="2" step="1" min="1"/>
        </div>
      </div>

      <label>Anchor mode</label>
      <select id="anchorMode">
        <option value="southCorner">south corner (game default)</option>
        <option value="center">center (footprint center)</option>
        <option value="southEdge">south edge center</option>
        <option value="customWorld">custom world (tiles)</option>
      </select>

      <div class="row" id="customWorldRow" style="display:none">
        <div>
          <label>custom world X (tiles)</label>
          <input id="customWX" type="number" value="0" step="0.25"/>
        </div>
        <div>
          <label>custom world Y (tiles)</label>
          <input id="customWY" type="number" value="0" step="0.25"/>
        </div>
      </div>

      <div class="checkRow" style="margin-top:8px">
        <input id="showTiles" type="checkbox" checked/>
        <div style="font-size:13px;opacity:.92">íƒ€ì¼ ê·¸ë¦¬ë“œ í‘œì‹œ</div>
      </div>
      <div class="checkRow" style="margin-top:6px">
        <input id="showOutline" type="checkbox" checked/>
        <div style="font-size:13px;opacity:.92">í’‹í”„ë¦°íŠ¸ ì™¸ê³½ì„  í‘œì‹œ</div>
      </div>
    </div>

    <label>Copy/paste output</label>
    <textarea id="out" spellcheck="false"></textarea>

    <div id="status" class="status">Ready.</div>
  </aside>

  <main id="right">
    <canvas id="cv"></canvas>
  </main>

<script>
const $ = (id)=>document.getElementById(id);
const cv = $('cv');
const ctx = cv.getContext('2d');

let dpr = Math.max(1, window.devicePixelRatio || 1);

function clamp01(n){ n = Number(n); if(!Number.isFinite(n)) return 0; return Math.max(0, Math.min(1, n)); }
function numOr(id, fallback){ const el = $(id); if(!el) return fallback; const n = Number(el.value); return Number.isFinite(n) ? n : fallback; }
function dirname(path){ const q = (path||'').split('?')[0]; const i = q.lastIndexOf('/'); return i>=0 ? q.slice(0,i+1) : ''; }

function setStatus(s){ $('status').textContent = s; }

function resizeCanvas(){
  const r = $('right').getBoundingClientRect();
  dpr = Math.max(1, window.devicePixelRatio || 1);
  cv.width = Math.floor(r.width * dpr);
  cv.height = Math.floor(r.height * dpr);
  cv.style.width = r.width + 'px';
  cv.style.height = r.height + 'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', resizeCanvas);

function extractTrailingNumber(name){
  const m = name.match(/(\d+)(?=\.png$)/i);
  if(!m) return null;
  return Number(m[1]);
}

let atlasData = null;
let basePath = '';
let textures = []; // {img, name}
let frames = [];   // merged frames for given prefix: [{name, texIndex, frame, rotated, sourceSize, spriteSourceSize, anchor, _ref}]
let cur = 0;
let playing = false;
let lastT = 0;

const LS_PIVOT_KEY = 'pivotTuner_prefixToPivot_v2';

function loadPersistedPivot(prefix){
  try{
    const raw = localStorage.getItem(LS_PIVOT_KEY);
    if(!raw) return null;
    const obj = JSON.parse(raw);
    return obj && obj[prefix] ? obj[prefix] : null;
  }catch(e){ return null; }
}
function persistPrefixPivot(prefix, x, y){
  try{
    const p = prefix.trim();
    if(!p) return {ok:false, reason:'empty prefix'};
    const raw = localStorage.getItem(LS_PIVOT_KEY);
    const obj = raw ? JSON.parse(raw) : {};
    obj[p] = {x, y};
    localStorage.setItem(LS_PIVOT_KEY, JSON.stringify(obj));
    return {ok:true};
  }catch(e){ return {ok:false, reason:String(e)}; }
}

function isHTMLLikely(s){
  if(typeof s!=='string') return false;
  const t = s.trim().toLowerCase();
  return t.startsWith('<!doctype') || t.startsWith('<html') || t.includes('<head') || t.includes('<body');
}

async function fetchJsonSmart(url){
  const res = await fetch(url, {cache:'no-store'});
  const txt = await res.text();
  if(!res.ok) throw new Error('HTTP ' + res.status + ' ' + res.statusText);
  if(isHTMLLikely(txt)) throw new Error('Atlas URL returned HTML (ê²½ë¡œ 404/fallback ê°€ëŠ¥ì„± ë†’ìŒ)');
  return JSON.parse(txt);
}

function loadImage(url){
  return new Promise((resolve,reject)=>{
    const img = new Image();
    img.onload = ()=>resolve(img);
    img.onerror = ()=>reject(new Error('failed to load image: ' + url));
    img.src = url;
  });
}

async function loadAtlas(){
  const url = $('atlasUrl').value.trim();
  if(!url){ setStatus('ERR: atlasUrl empty'); return; }
  setStatus('Loading atlas JSON...');
  atlasData = await fetchJsonSmart(url);
  basePath = dirname(url);

  // load multipack textures
  textures = [];
  setStatus('Loading textures...');
  for(const tex of (atlasData.textures||[])){
    const texName = tex.image;
    const texUrl = texName.startsWith('http') ? texName : basePath + texName;
    const img = await loadImage(texUrl);
    textures.push({img, name: texName});
  }
  setStatus('Loaded textures: ' + textures.length);

  rebuildFramesByPrefix(true);
  render();
}

function rebuildFramesByPrefix(resetPivotFromSaved){
  frames = [];
  if(!atlasData) return;
  const prefix = $('prefix').value.trim();
  const list = [];
  (atlasData.textures||[]).forEach((tex, texIndex)=>{
    (tex.frames||[]).forEach(fr=>{
      const name = fr.filename;
      if(!prefix || name.startsWith(prefix)){
        list.push({
          name,
          texIndex,
          frame: fr.frame,
          rotated: !!fr.rotated,
          sourceSize: fr.sourceSize,
          spriteSourceSize: fr.spriteSourceSize,
          anchor: fr.anchor ? {x: fr.anchor.x, y: fr.anchor.y} : {x:0.5,y:0.5},
          _ref: fr
        });
      }
    });
  });

  list.sort((a,b)=>{
    const na = extractTrailingNumber(a.name);
    const nb = extractTrailingNumber(b.name);
    if(na!=null && nb!=null) return na-nb;
    if(na!=null && nb==null) return -1;
    if(na==null && nb!=null) return 1;
    return a.name.localeCompare(b.name);
  });

  frames = list;
  cur = 0;

  if(resetPivotFromSaved){
    const saved = loadPersistedPivot(prefix);
    if(saved){
      $('pivotX').value = clamp01(saved.x);
      $('pivotY').value = clamp01(saved.y);
    }
  }
  setStatus('Frames: ' + frames.length + (prefix? (' (prefix: ' + prefix + ')') : ''));
}

function buildUntrimmedCanvas(f){
  const fullW = f.sourceSize?.w ?? f.frame.w;
  const fullH = f.sourceSize?.h ?? f.frame.h;

  const off = document.createElement('canvas');
  off.width = fullW;
  off.height = fullH;
  const octx = off.getContext('2d');

  const tex = textures[f.texIndex]?.img;
  if(!tex) return {canvas:off, w:fullW, h:fullH};

  const fr = f.frame;
  const ss = f.spriteSourceSize ?? {x:0,y:0,w:fr.w,h:fr.h};

  if(f.rotated){
    // rotated frame: draw to temp, rotate into untrimmed
    const tmp = document.createElement('canvas');
    tmp.width = fr.h;
    tmp.height = fr.w;
    const tctx = tmp.getContext('2d');
    tctx.drawImage(tex, fr.x, fr.y, fr.w, fr.h, 0, 0, fr.h, fr.w);

    octx.save();
    octx.translate(ss.x + ss.w/2, ss.y + ss.h/2);
    octx.rotate(-Math.PI/2);
    octx.drawImage(tmp, -ss.h/2, -ss.w/2, ss.h, ss.w);
    octx.restore();
  }else{
    octx.drawImage(tex, fr.x, fr.y, fr.w, fr.h, ss.x, ss.y, fr.w, fr.h);
  }

  return {canvas:off, w:fullW, h:fullH};
}

// -------- Game placement math (from game.js) --------
function computeIsoConsts(){
  const TILE = numOr('TILE',128);
  const ISO_X = TILE/2;
  const ISO_Y = TILE/4;
  return {TILE, ISO_X, ISO_Y};
}
function worldToIso(wx, wy, TILE, ISO_X, ISO_Y){
  return { x: (wx - wy) * (ISO_X / TILE), y: (wx + wy) * (ISO_Y / TILE) };
}
function worldToScreen(wx, wy, opt){
  const {TILE, ISO_X, ISO_Y} = opt;
  const iso = worldToIso(wx, wy, TILE, ISO_X, ISO_Y);

  // camera in tiles -> world pixels
  const camWX = opt.camTX * TILE;
  const camWY = opt.camTY * TILE;
  const camIso = worldToIso(camWX, camWY, TILE, ISO_X, ISO_Y);

  return {
    x: (iso.x - camIso.x) * opt.zoom + opt.baseX,
    y: (iso.y - camIso.y) * opt.zoom + opt.baseY
  };
}

function drawCross(x,y, size, color){
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(x-size, y);
  ctx.lineTo(x+size, y);
  ctx.moveTo(x, y-size);
  ctx.lineTo(x, y+size);
  ctx.stroke();
  ctx.restore();
}

function drawTileDiamondAt(cx, cy, TILE, zoom){
  const w = TILE * zoom;
  const h = (TILE/2) * zoom;
  ctx.beginPath();
  ctx.moveTo(cx, cy - h/2);
  ctx.lineTo(cx + w/2, cy);
  ctx.lineTo(cx, cy + h/2);
  ctx.lineTo(cx - w/2, cy);
  ctx.closePath();
  ctx.stroke();
}

function drawFootprintOverlay(opt){
  const {TILE} = opt;
  const zoom = opt.zoom;
  const tx = opt.bTX, ty = opt.bTY, tw = opt.bTW, th = opt.bTH;

  if($('showTiles').checked){
    ctx.save();
    ctx.globalAlpha = 0.65;
    ctx.strokeStyle = 'rgba(100,170,255,0.85)';
    ctx.lineWidth = 1;

    for(let y=0;y<th;y++){
      for(let x=0;x<tw;x++){
        const wx = (tx + x + 0.5) * TILE;
        const wy = (ty + y + 0.5) * TILE;
        const p = worldToScreen(wx, wy, opt);
        drawTileDiamondAt(p.x, p.y, TILE, zoom);
      }
    }
    ctx.restore();
  }

  if($('showOutline').checked){
    const nw = worldToScreen((tx)*TILE, (ty)*TILE, opt);
    const ne = worldToScreen((tx+tw)*TILE, (ty)*TILE, opt);
    const se = worldToScreen((tx+tw)*TILE, (ty+th)*TILE, opt);
    const sw = worldToScreen((tx)*TILE, (ty+th)*TILE, opt);

    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.strokeStyle = 'rgba(0,255,160,0.85)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(nw.x, nw.y);
    ctx.lineTo(ne.x, ne.y);
    ctx.lineTo(se.x, se.y);
    ctx.lineTo(sw.x, sw.y);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }
}

function computeAnchorScreen(opt){
  const {TILE} = opt;
  const tx = opt.bTX, ty = opt.bTY, tw = opt.bTW, th = opt.bTH;
  const mode = $('anchorMode').value;

  let wx, wy;
  if(mode==='center'){
    wx = (tx + tw*0.5) * TILE;
    wy = (ty + th*0.5) * TILE;
  }else if(mode==='southEdge'){
    wx = (tx + tw*0.5) * TILE;
    wy = (ty + th) * TILE;
  }else if(mode==='customWorld'){
    wx = numOr('customWX',0) * TILE;
    wy = numOr('customWY',0) * TILE;
  }else{ // southCorner
    wx = (tx + tw) * TILE;
    wy = (ty + th) * TILE;
  }
  return worldToScreen(wx, wy, opt);
}

// -------- Render --------
function render(){
  const r = $('right').getBoundingClientRect();
  ctx.clearRect(0,0,r.width,r.height);

  const baseX = r.width/2;
  const baseY = r.height/2;

  const useGame = $('useGame').checked;

  let anchor = {x:baseX, y:baseY};
  let overlayInfo = '';
  if(useGame){
    const {TILE, ISO_X, ISO_Y} = computeIsoConsts();
    const camZoom = numOr('camZoom',1);
    const camTX = numOr('camTX',0);
    const camTY = numOr('camTY',0);
    const bTX = numOr('bTX',0);
    const bTY = numOr('bTY',0);
    const bTW = numOr('bTW',3);
    const bTH = numOr('bTH',2);

    const opt = {TILE, ISO_X, ISO_Y, zoom:camZoom, camTX, camTY, baseX, baseY, bTX, bTY, bTW, bTH};

    // footprint + anchor
    drawFootprintOverlay(opt);
    anchor = computeAnchorScreen(opt);

    // draw anchor cross
    drawCross(anchor.x, anchor.y, 10, 'rgba(255,255,255,0.9)');
    drawCross(anchor.x, anchor.y, 20, 'rgba(255,120,0,0.7)');

    overlayInfo = `TILE=${TILE} ISO_X=${ISO_X} ISO_Y=${ISO_Y} camZoom=${camZoom} camTile=(${camTX},${camTY})\n` +
                  `bTile=(${bTX},${bTY}) footprint=(${bTW}x${bTH}) anchorMode=${$('anchorMode').value} anchorScreen=(${anchor.x.toFixed(1)},${anchor.y.toFixed(1)})`;
  }else{
    // legacy: center diamond footprint
    const tileW = 128;
    const tileH = 64;
    const tilesX = numOr('bTW',3);
    const tilesY = numOr('bTH',2);

    ctx.save();
    ctx.globalAlpha = 0.75;
    ctx.strokeStyle = 'rgba(100,170,255,0.85)';
    ctx.lineWidth = 1;
    for(let y=0;y<tilesY;y++){
      for(let x=0;x<tilesX;x++){
        const ox = (x - y) * (tileW/2);
        const oy = (x + y) * (tileH/2);
        ctx.beginPath();
        ctx.moveTo(baseX + ox, baseY + oy - tileH/2);
        ctx.lineTo(baseX + ox + tileW/2, baseY + oy);
        ctx.lineTo(baseX + ox, baseY + oy + tileH/2);
        ctx.lineTo(baseX + ox - tileW/2, baseY + oy);
        ctx.closePath();
        ctx.stroke();
      }
    }
    ctx.restore();

    anchor = {x:baseX, y:baseY};
    drawCross(anchor.x, anchor.y, 10, 'rgba(255,255,255,0.9)');
    overlayInfo = 'Legacy overlay: anchor at canvas center';
  }

  if(!frames.length){
    $('out').value = overlayInfo;
    return;
  }

  const f = frames[cur];
  const scale = numOr('scale',0.14) * (useGame ? numOr('camZoom',1) : 1);
  const px = clamp01($('pivotX').value);
  const py = clamp01($('pivotY').value);

  const {canvas, w, h} = buildUntrimmedCanvas(f);
  const drawW = w * scale;
  const drawH = h * scale;

  // pivot point aligns to computed anchor
  const dx = anchor.x - (px * drawW);
  const dy = anchor.y - (py * drawH);

  // draw sprite
  ctx.save();
  ctx.imageSmoothingEnabled = true;
  ctx.globalAlpha = 1;
  ctx.drawImage(canvas, dx, dy, drawW, drawH);
  ctx.restore();

  // label
  ctx.save();
  ctx.fillStyle = 'rgba(230,238,252,0.95)';
  ctx.font = '13px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
  ctx.fillText(f.name, 14, 22);
  ctx.restore();

  // debug output
  const pivotPx = (px * w);
  const pivotPy = (py * h);
  const tri = f.frame;
  const ss = f.spriteSourceSize ?? {x:0,y:0,w:tri.w,h:tri.h};

  $('out').value =
    overlayInfo + '\n\n' +
    `frame=${f.name}\n` +
    `sourceSize=${w}x${h} pivot(norm)=(${px.toFixed(4)},${py.toFixed(4)}) pivot(px)=(${pivotPx.toFixed(1)},${pivotPy.toFixed(1)})\n` +
    `trim(frame)=${tri.w}x${tri.h} @(${tri.x},${tri.y}) rotated=${!!f.rotated}\n` +
    `spriteSourceSize=${ss.w}x${ss.h} @(${ss.x},${ss.y})\n` +
    `suggest JSON anchor: {"x": ${px.toFixed(4)}, "y": ${py.toFixed(4)}}`;
}

function stepFrame(dir){
  if(!frames.length) return;
  cur = (cur + dir + frames.length) % frames.length;
  render();
}

function tick(t){
  if(!playing){ requestAnimationFrame(tick); return; }
  const fps = Math.max(1, numOr('fps',20));
  const dt = t - lastT;
  const frameDur = 1000 / fps;
  if(dt >= frameDur){
    lastT = t;
    stepFrame(1);
  }
  requestAnimationFrame(tick);
}

function applyPivotTo(names){
  if(!atlasData) return;
  const x = clamp01($('pivotX').value);
  const y = clamp01($('pivotY').value);

  const prefix = $('prefix').value;
  const persist = persistPrefixPivot(prefix, x, y);

  const nameSet = new Set(names);
  let changed = 0;

  (atlasData.textures||[]).forEach(tex=>{
    (tex.frames||[]).forEach(fr=>{
      if(nameSet.has(fr.filename)){
        fr.anchor = {x, y};
        changed++;
      }
    });
  });

  const note = persist.ok ? ` + saved to localStorage (${LS_PIVOT_KEY})` : ` (not saved: ${persist.reason})`;
  setStatus(`Applied pivot (${x.toFixed(4)},${y.toFixed(4)}) to ${changed} frame(s).` + note);
}

function applyCurrent(){
  if(!frames.length) return;
  applyPivotTo([frames[cur].name]);
}
function applyAll(){
  if(!frames.length) return;
  applyPivotTo(frames.map(f=>f.name));
}

function downloadPatched(){
  if(!atlasData) { setStatus('ERR: atlas not loaded'); return; }
  const url = $('atlasUrl').value.trim();
  const filename = (url.split('?')[0].split('/').pop() || 'atlas_patched.json');
  const blob = new Blob([JSON.stringify(atlasData, null, 2)], {type:'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setStatus('Downloaded patched JSON: ' + filename);
}

function copyJSOverride(){
  const prefix = $('prefix').value.trim();
  const x = clamp01($('pivotX').value);
  const y = clamp01($('pivotY').value);

  const snippet =
`// paste into your atlas override map (prefix based)
const PIVOT_OVERRIDES = {
  "${prefix}": { x: ${x.toFixed(4)}, y: ${y.toFixed(4)} }
};`;
  navigator.clipboard.writeText(snippet).then(()=>{
    setStatus('Copied JS override to clipboard.');
  }).catch(()=>{
    setStatus('ERR: clipboard write failed (ë¸Œë¼ìš°ì € ê¶Œí•œ í™•ì¸)');
  });
}

function toggleCustomWorld(){
  $('customWorldRow').style.display = ($('anchorMode').value === 'customWorld') ? '' : 'none';
}

$('btnLoad').addEventListener('click', ()=>loadAtlas().catch(e=>setStatus('ERR: ' + e.message)));
$('btnPlay').addEventListener('click', ()=>{
  playing = !playing;
  $('btnPlay').textContent = playing ? 'Pause' : 'Play';
});
$('btnPrev').addEventListener('click', ()=>stepFrame(-1));
$('btnNext').addEventListener('click', ()=>stepFrame(1));
$('btnApplyCur').addEventListener('click', ()=>applyCurrent());
$('btnApplyAll').addEventListener('click', ()=>applyAll());
$('btnDownload').addEventListener('click', ()=>downloadPatched());
$('btnCopyJS').addEventListener('click', ()=>copyJSOverride());

$('prefix').addEventListener('change', ()=>{
  rebuildFramesByPrefix(true);
  render();
});

$('anchorMode').addEventListener('change', ()=>{
  toggleCustomWorld();
  render();
});

[
  'pivotX','pivotY','fps','scale','useGame',
  'TILE','camZoom','camTX','camTY','bTX','bTY','bTW','bTH',
  'customWX','customWY','showTiles','showOutline'
].forEach(id=>{
  const el = $(id);
  if(el) el.addEventListener('input', ()=>render());
});

resizeCanvas();
toggleCustomWorld();
render();
requestAnimationFrame(tick);
</script>
</body>
</html>
